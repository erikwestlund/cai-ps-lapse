---
title: "Reviewer Response Analysis"
author: "Erik Westlund"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 6
)

# Load required libraries and settings
source("settings.R")
source("functions.R")

# Load all required libraries
load_required_libraries()
```

# Data Preparation

```{r load_data}
# Load and prepare data
data_path <- file.path(s_root, "Gina's Project/df_Final_240909.csv")
data <- load_and_prepare_data(data_path)

# Apply the same exclusions as main analysis
m_data <- apply_exclusions(data)

print(sprintf("Total observations after exclusions: %d", nrow(m_data)))
print(sprintf("Total unique patients: %d", length(unique(m_data$e_mrn_deidentified))))
```

## Load IPTW Weights from Analysis

```{r twang_weights}
# Load cached results from the main analysis pipeline
cached_results <- load_cached_results("ps_results")

# Check if twang model exists in cached results
if(!"twang_gbm" %in% names(cached_results)) {
  stop("No cached twang model found. Please run analysis.Rmd first to generate IPTW weights.")
}

print("Loading cached twang model for IPTW weights...")
twang_model <- cached_results$twang_gbm$result

# Extract IPTW weights from twang model (same as in analysis.Rmd)
m_data$twang_att_w <- get.weights(twang_model, stop.method = "es.mean")

# Summary of weights
print("Weight distribution:")
summary(m_data$twang_att_w)
```

## Main Effect of Lapsing (IPTW-Weighted)

```{r main_effect}
# Run the main model with full covariates to get the lapse effect
# Using the same formula as analysisFormulaFull from functions.R
main_formula <- get_analysis_formulas()$full

# Create weighted survey design
survey_design_weighted <- svydesign(
  ids = ~e_mrn_deidentified,
  data = m_data,
  weights = ~twang_att_w
)

# Fit the main model
main_model <- svyglm(
  formula = main_formula,
  design = survey_design_weighted,
  family = quasibinomial()
)

# Extract lapse effect
coef_summary <- summary(main_model)$coefficients
lapse_est <- coef_summary["ever_lapse_binary", "Estimate"]
lapse_se <- coef_summary["ever_lapse_binary", "Std. Error"]
lapse_p <- coef_summary["ever_lapse_binary", "Pr(>|t|)"]

# Calculate confidence intervals
lapse_ci <- confint(main_model)["ever_lapse_binary", ]

# Create results table
lapse_results <- data.frame(
  Log_Odds = round(lapse_est, 4),
  Odds_Ratio = round(exp(lapse_est), 4),
  CI_Lower = round(lapse_ci[1], 4),
  CI_Upper = round(lapse_ci[2], 4),
  P_Value = format.pval(lapse_p, digits = 4, eps = 0.0001)
)

knitr::kable(lapse_results, 
             caption = "Effect of Lapsing on Vision Impairment (IPTW-Weighted)",
             row.names = FALSE)
```

# Reviewer Question 1: Subgroup Testing with Formal Interaction Terms

**Reviewer Comment:** "Inadequate Subgroup Testing: Visual forest‑plot overlap doesn't prove consistent effects across subgroups (e.g., PDR+anti‑VEGF vs. PDR+PRP). Without formal interaction testing, subgroup claims lack statistical backing."

**Response:** We perform formal interaction testing using two models:
1. Interaction between lapse status and DR severity
2. Interaction between lapse status and treatment type

## Create Analysis Variables

```{r create_variables}
# Create the treatment type variable and properly labeled DR severity
m_data <- m_data |>
  mutate(
    treatment_type = case_when(
      anti_VEGF == 1 ~ "anti_VEGF",
      PRP_flag == 1 ~ "PRP",
      other_inject == 1 | focal_laser_flag == 1 ~ "other_treatment",
      TRUE ~ "no_treatment"
    ),
    treatment_type = factor(treatment_type, 
                           levels = c("no_treatment", "anti_VEGF", "PRP", "other_treatment")),
    # Create labeled DR severity factor for clearer interaction terms
    dr_severity = factor(person_dr,
                        levels = c(0, 1, 2),
                        labels = c("No_DR", "NPDR", "PDR"))
  )

# Check distribution of treatment types
print("Treatment Type Distribution:")
table(m_data$treatment_type)

# Display DR severity coding and distribution
print("DR Severity Distribution:")
table(m_data$dr_severity)
```

## Variable Definitions

```{r variable_definitions}
# Create a reference table for all key variables
variable_definitions <- data.frame(
  Variable = c("ever_lapse_binary", "outcome_va_vi_binary", "dr_severity", 
               "treatment_type", "person_dr", "person_dr_severity"),
  Type = c("Binary", "Binary", "Factor", "Factor", "Numeric", "Numeric"),
  Values = c("0 = No lapse, 1 = Lapsed from care",
             "0 = No vision impairment, 1 = Vision impairment (VA ≥ 0.3 logMAR)",
             "No_DR, NPDR, PDR (labeled factor for interactions)",
             "no_treatment, anti_VEGF, PRP, other_treatment",
             "0 = No DR, 1 = NPDR, 2 = PDR (numeric coding)",
             "0 = No DR, 1 = Mild NPDR, 2 = Moderate NPDR, 3 = Severe NPDR, 4 = PDR"),
  stringsAsFactors = FALSE
)

knitr::kable(variable_definitions, 
             caption = "Key Variable Definitions",
             col.names = c("Variable", "Type", "Possible Values/Coding"))
```

## Define Model Formulas

```{r define_formulas}
# Define the base formula (same as analysisFormulaFull but without the outcome)
base_covariates <- c(
  "gender_cat",
  "race_ethnic_cat", 
  "insurance_cat",
  "age_cat",
  "CCI",
  "DCSI",
  "other_inject",
  "anti_VEGF",
  "focal_laser_flag",
  "PRP_flag",
  "glaucoma_bef_hitplus_cat",
  "otherretina_bef_hitplus_cat",
  "catsurg_before_hitplus_cat"
)

# Model 1: Interaction with DR severity
# dr_severity: No_DR, NPDR, PDR
interaction_dr_formula <- as.formula(paste(
  "outcome_va_vi_binary ~ ever_lapse_binary * dr_severity +",
  paste(base_covariates, collapse = " + ")
))

# Model 2: Interaction with treatment type
interaction_treatment_formula <- as.formula(paste(
  "outcome_va_vi_binary ~ ever_lapse_binary * treatment_type +",
  paste(base_covariates, collapse = " + ")
))

print("DR Interaction Formula:")
print(interaction_dr_formula)

print("Treatment Interaction Formula:")
print(interaction_treatment_formula)
```

## Run Interaction Models (IPTW Weighted)

```{r interaction_models, results='asis'}
# Store results for weighted analyses only
interaction_results <- list()

# Create weighted survey design
survey_design_weighted <- svydesign(
  ids = ~e_mrn_deidentified,
  data = m_data,
  weights = ~twang_att_w
)

### DR Severity Interaction Model

```{r dr_interaction}
# Fit Model 1: DR severity interaction
model_dr_interaction <- svyglm(
  formula = interaction_dr_formula,
  design = survey_design_weighted,
  family = quasibinomial()
)

# Summary of DR interaction model
summary_dr <- summary(model_dr_interaction)

# Extract interaction p-values for DR model
dr_interaction_terms <- grep("ever_lapse_binary:dr_severity", 
                            names(coef(model_dr_interaction)), value = TRUE)
dr_interaction_pvals <- if(length(dr_interaction_terms) > 0) {
  summary_dr$coefficients[dr_interaction_terms, "Pr(>|t|)"]
} else {
  numeric(0)
}

# Display results
dr_results <- data.frame(
  Term = dr_interaction_terms,
  Coefficient = summary_dr$coefficients[dr_interaction_terms, "Estimate"],
  SE = summary_dr$coefficients[dr_interaction_terms, "Std. Error"],
  P_Value = round(dr_interaction_pvals, 4),
  Significant = ifelse(dr_interaction_pvals < 0.05, "Yes", "No")
)

knitr::kable(dr_results, caption = "DR Severity Interaction Terms (Individual Coefficients)")
```

## Understanding the Interaction Model

In the interaction model `outcome ~ lapse * dr_severity`, the coefficients represent:

- **Main effect of lapse (β₁)**: Effect of lapsing for the reference group (No DR)
- **Main effects of DR severity (β₂, β₃)**: Baseline differences in risk for NPDR/PDR vs No DR among non-lapsers
- **Interaction terms (β₄, β₅)**: How much the effect of lapsing differs in NPDR/PDR compared to No DR

The actual effect of lapsing within each DR group is:
- **No DR**: β₁
- **NPDR**: β₁ + β₄ 
- **PDR**: β₁ + β₅

## Joint Test of Interaction Terms

```{r joint_interaction_test}

# Joint Wald test: Are the interaction terms jointly significant?
# H0: ever_lapse_binary:dr_severityNPDR = 0 AND ever_lapse_binary:dr_severityPDR = 0
# This tests whether the effect of lapsing is the same across all DR severity levels

joint_test <- linearHypothesis(
  model_dr_interaction,
  c("ever_lapse_binary:dr_severityNPDR = 0",
    "ever_lapse_binary:dr_severityPDR = 0"),
  vcov = vcov(model_dr_interaction)
)

# Display joint test results
joint_results <- data.frame(
  Test = "Joint interaction test",
  Chisq = round(joint_test$Chisq[2], 3),
  Df = joint_test$Df[2],
  P_Value = format.pval(joint_test$`Pr(>Chisq)`[2], digits = 4, eps = 0.0001)
)

knitr::kable(joint_results, 
             caption = "Joint Wald Test for DR Severity Interactions",
             row.names = FALSE)

# Interpret the joint test
if(joint_test$`Pr(>Chisq)`[2] < 0.05) {
  print("Joint test is significant: The effect of lapsing varies by DR severity")
} else {
  print("Joint test is not significant: The effect of lapsing is similar across DR severity levels")
}
```

## Effect of Lapsing Within Each DR Severity Group

```{r lapse_effects_by_dr}

# Method 1: Use emmeans WITHOUT nuisance factors for true marginalization
# Increase reference grid limit to handle the full factorial
emm_options(rg.limit = 200000)  # Increase limit to handle large reference grid

# Check for cached emmeans results
emmeans_cache_file <- "ps_results/emmeans_dr_interaction.rds"
if(file.exists(emmeans_cache_file)) {
  cat("Loading cached emmeans results...\n")
  emmeans_results <- readRDS(emmeans_cache_file)
  emm <- emmeans_results$emm
  lapse_contrasts <- emmeans_results$lapse_contrasts
  cat("Cached results loaded successfully.\n\n")
} else {
  cat("Computing emmeans (this may take several minutes)...\n")
  start_time <- Sys.time()
  
  # Calculate marginal means - this will average over all covariate combinations
  emm <- emmeans(model_dr_interaction, 
                 ~ ever_lapse_binary | dr_severity)
  
  # Get contrasts: effect of lapse (1 vs 0) within each DR severity
  lapse_contrasts <- contrast(emm, method = "revpairwise", by = "dr_severity")
  
  # Save to cache
  emmeans_results <- list(
    emm = emm,
    lapse_contrasts = lapse_contrasts,
    computed_at = Sys.time()
  )
  saveRDS(emmeans_results, file = emmeans_cache_file)
  
  end_time <- Sys.time()
  cat("Emmeans computation completed in", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")
  cat("Results cached to:", emmeans_cache_file, "\n\n")
}

# Convert to data frame and clean up
lapse_effects <- as.data.frame(lapse_contrasts)

# Create clean results table
lapse_effects_table <- data.frame(
  DR_Severity = lapse_effects$dr_severity,
  Log_Odds = round(lapse_effects$estimate, 4),
  SE = round(lapse_effects$SE, 4),
  CI_Lower = round(lapse_effects$estimate - 1.96 * lapse_effects$SE, 4),
  CI_Upper = round(lapse_effects$estimate + 1.96 * lapse_effects$SE, 4),
  Odds_Ratio = round(exp(lapse_effects$estimate), 4),
  P_Value = format.pval(lapse_effects$p.value, digits = 4, eps = 0.0001)
)

knitr::kable(lapse_effects_table,
             caption = "Effect of Lapsing Within Each DR Severity Group",
             row.names = FALSE)
```

## Alternative: Manual Calculation of Lapse Effects

```{r manual_lapse_effects}
# Note: This manual calculation should produce identical results to emmeans above
# If emmeans still has issues, we can calculate the effects manually
# Extract coefficients and variance-covariance matrix
coef_vals <- coef(model_dr_interaction)
vcov_mat <- vcov(model_dr_interaction)

# Define the linear combinations for each DR group
# Effect in No DR: just the main effect
# Effect in NPDR: main effect + NPDR interaction
# Effect in PDR: main effect + PDR interaction

# Create contrast matrix
contrast_names <- c("Lapse effect in No DR",
                    "Lapse effect in NPDR", 
                    "Lapse effect in PDR")

# Initialize results
manual_effects <- data.frame(
  DR_Severity = c("No_DR", "NPDR", "PDR"),
  Log_Odds = numeric(3),
  SE = numeric(3),
  stringsAsFactors = FALSE
)

# Effect for No DR (just main effect)
manual_effects$Log_Odds[1] <- coef_vals["ever_lapse_binary"]
manual_effects$SE[1] <- sqrt(vcov_mat["ever_lapse_binary", "ever_lapse_binary"])

# Effect for NPDR (main + interaction)
if("ever_lapse_binary:dr_severityNPDR" %in% names(coef_vals)) {
  manual_effects$Log_Odds[2] <- coef_vals["ever_lapse_binary"] + 
                                 coef_vals["ever_lapse_binary:dr_severityNPDR"]
  # SE calculation for sum of coefficients
  manual_effects$SE[2] <- sqrt(
    vcov_mat["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat["ever_lapse_binary:dr_severityNPDR", "ever_lapse_binary:dr_severityNPDR"] +
    2 * vcov_mat["ever_lapse_binary", "ever_lapse_binary:dr_severityNPDR"]
  )
}

# Effect for PDR (main + interaction)
if("ever_lapse_binary:dr_severityPDR" %in% names(coef_vals)) {
  manual_effects$Log_Odds[3] <- coef_vals["ever_lapse_binary"] + 
                                 coef_vals["ever_lapse_binary:dr_severityPDR"]
  # SE calculation for sum of coefficients
  manual_effects$SE[3] <- sqrt(
    vcov_mat["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat["ever_lapse_binary:dr_severityPDR", "ever_lapse_binary:dr_severityPDR"] +
    2 * vcov_mat["ever_lapse_binary", "ever_lapse_binary:dr_severityPDR"]
  )
}

# Calculate CIs and OR
manual_effects <- manual_effects |>
  mutate(
    CI_Lower = Log_Odds - 1.96 * SE,
    CI_Upper = Log_Odds + 1.96 * SE,
    Odds_Ratio = exp(Log_Odds),
    # Calculate p-values (two-sided test)
    Z_stat = Log_Odds / SE,
    P_Value = 2 * pnorm(-abs(Z_stat))
  ) |>
  mutate(
    Log_Odds = round(Log_Odds, 4),
    SE = round(SE, 4),
    CI_Lower = round(CI_Lower, 4),
    CI_Upper = round(CI_Upper, 4),
    Odds_Ratio = round(Odds_Ratio, 4),
    P_Value = format.pval(P_Value, digits = 4, eps = 0.0001)
  ) |>
  select(-Z_stat)

knitr::kable(manual_effects,
             caption = "Effect of Lapsing Within Each DR Severity Group (Manual Calculation)",
             row.names = FALSE)

# Verify that emmeans and manual calculations match
if(exists("lapse_effects_table") && nrow(lapse_effects_table) > 0) {
  # Compare the two methods
  comparison <- data.frame(
    DR_Severity = manual_effects$DR_Severity,
    Emmeans_LogOdds = lapse_effects_table$Log_Odds,
    Manual_LogOdds = manual_effects$Log_Odds,
    Difference = abs(lapse_effects_table$Log_Odds - manual_effects$Log_Odds)
  )
  
  if(max(comparison$Difference) < 0.001) {
    cat("\n✓ Verification: Emmeans and manual calculations produce identical results (differences < 0.001)\n")
  } else {
    cat("\n⚠ Warning: Some differences between emmeans and manual calculations:\n")
    print(comparison)
  }
} else {
  cat("\nNote: Using manual calculation method as emmeans encountered issues with reference grid size.\n")
}
```

## Visualization of Interaction Effects

```{r visualize_interactions, fig.height=6, fig.width=10}
# Use the manual_effects data for visualization
plot_data <- manual_effects

# Bar chart showing magnitude of effects with error bars
p_magnitude <- ggplot(plot_data, aes(x = DR_Severity, y = Log_Odds, fill = DR_Severity)) +
  geom_col(alpha = 0.7) +
  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper), 
                width = 0.2, size = 1) +
  geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +
  labs(title = "Magnitude of Lapse Effect Across DR Severity",
       subtitle = "Note: Confidence intervals for No DR and NPDR overlap",
       x = "DR Severity",
       y = "Log Odds (Effect Size)") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12),
        legend.position = "none") +
  scale_fill_manual(values = c("No_DR" = "#1f77b4", 
                               "NPDR" = "#ff7f0e", 
                               "PDR" = "#d62728")) +
  geom_text(aes(label = sprintf("OR: %.2f", Odds_Ratio)),
            vjust = ifelse(plot_data$Log_Odds > 0, -1, 1.5),
            size = 4)

print(p_magnitude)
```

## Predicted Probabilities and Differences by Lapse Status

```{r probability_table_emmeans}
# Try to compute emmeans on probability scale with error handling
compute_prob_table <- tryCatch({
  # Increase reference grid limit to handle all combinations
  emm_options(rg.limit = 200000)
  
  # Get predicted probabilities on the response scale
  # This will average over all covariate combinations
  emm_probs <- emmeans(model_dr_interaction, 
                       ~ ever_lapse_binary | dr_severity,
                       type = "response")
  
  # Convert to data frame for manipulation
  prob_summary <- as.data.frame(emm_probs)
  
  # Check if we have the expected structure
  if(nrow(prob_summary) == 0) {
    stop("emmeans returned empty results")
  }
  
  # Calculate differences manually from the emmeans object
  prob_contrasts <- contrast(emm_probs, method = "revpairwise", by = "dr_severity")
  prob_diff_emmeans <- as.data.frame(prob_contrasts)
  
  # Check structure before creating table
  n_dr_levels <- length(unique(prob_summary$dr_severity))
  expected_rows <- n_dr_levels * 2
  
  if(nrow(prob_summary) != expected_rows) {
    warning(paste("Expected", expected_rows, "rows but got", nrow(prob_summary)))
  }
  
  # Create a clean table with probabilities for each group
  # Reorganize the data more carefully
  prob_table <- data.frame()
  for(dr_level in unique(prob_summary$dr_severity)) {
    dr_data <- prob_summary[prob_summary$dr_severity == dr_level, ]
    if(nrow(dr_data) == 2) {
      prob_table <- rbind(prob_table,
                          data.frame(
                            DR_Severity = dr_level,
                            Prob_No_Lapse = dr_data$prob[dr_data$ever_lapse_binary == 0],
                            Prob_Lapse = dr_data$prob[dr_data$ever_lapse_binary == 1]
                          ))
    }
  }
  
  # Add differences if available
  if(nrow(prob_diff_emmeans) > 0 && nrow(prob_table) > 0) {
    prob_table$Difference = prob_diff_emmeans$estimate
    prob_table$CI_Lower = prob_diff_emmeans$asymp.LCL
    prob_table$CI_Upper = prob_diff_emmeans$asymp.UCL
    prob_table$P_Value = prob_diff_emmeans$p.value
  } else {
    prob_table$Difference = NA
    prob_table$CI_Lower = NA
    prob_table$CI_Upper = NA
    prob_table$P_Value = NA
  }
  
  TRUE  # Success indicator
}, error = function(e) {
  cat("Note: Could not compute emmeans probabilities on response scale.\n")
  cat("Error:", e$message, "\n")
  cat("This may be due to the large reference grid size.\n")
  cat("Using manual calculation method instead (see next section).\n\n")
  FALSE  # Failure indicator
})

# Only create and display table if computation succeeded
if(compute_prob_table == TRUE && exists("prob_table") && nrow(prob_table) > 0) {
  # Format the table for display - check which columns exist
  display_table <- prob_table |>
    mutate(
      Prob_No_Lapse = round(Prob_No_Lapse, 3),
      Prob_Lapse = round(Prob_Lapse, 3)
    )
  
  # Add optional columns if they exist
  if("Difference" %in% names(prob_table)) {
    display_table <- display_table |>
      mutate(Difference = round(Difference, 3))
  }
  
  if(all(c("CI_Lower", "CI_Upper") %in% names(prob_table))) {
    display_table <- display_table |>
      mutate(CI = paste0("(", round(CI_Lower, 3), ", ", round(CI_Upper, 3), ")"))
  }
  
  if("P_Value" %in% names(prob_table)) {
    display_table <- display_table |>
      mutate(P_Value = format.pval(P_Value, digits = 3, eps = 0.001))
  }
  
  # Select only columns that exist
  cols_to_select <- c("DR_Severity", "Prob_No_Lapse", "Prob_Lapse")
  if("Difference" %in% names(display_table)) cols_to_select <- c(cols_to_select, "Difference")
  if("CI" %in% names(display_table)) cols_to_select <- c(cols_to_select, "CI")
  if("P_Value" %in% names(display_table)) cols_to_select <- c(cols_to_select, "P_Value")
  
  display_table <- display_table |> select(all_of(cols_to_select))
  
  # Adjust column names based on what's available
  col_names <- c("DR Severity", "P(VI | No Lapse)", "P(VI | Lapse)")
  if("Difference" %in% names(display_table)) col_names <- c(col_names, "Difference")
  if("CI" %in% names(display_table)) col_names <- c(col_names, "95% CI")
  if("P_Value" %in% names(display_table)) col_names <- c(col_names, "P-value")
  
  knitr::kable(display_table,
               caption = "Predicted Probability of Vision Impairment by DR Severity and Lapse Status (Averaged Over All Covariate Patterns)",
               col.names = col_names,
               row.names = FALSE,
               digits = 3)
} else {
  cat("Skipping emmeans probability table due to computation issues.\n")
  cat("See manual calculation in the next section for probability differences.\n")
}
```

## Average Marginal Effects by DR Severity Using Margins Package

```{r margins_dr_severity}
# Calculate AMEs for each DR severity group using margins package
# This matches the approach in twang-analysis.Rmd

cat("Calculating Average Marginal Effects using margins package...\n\n")

# Initialize results storage
ame_results <- data.frame()

# Try to calculate overall AME first
overall_success <- tryCatch({
  avg_margfx_overall <- margins(model_dr_interaction, design = survey_design_weighted, 
                                variables = "ever_lapse_binary")
  mfx_overall <- summary(avg_margfx_overall)
  
  ame_results <- rbind(ame_results, data.frame(
    DR_Severity = "Overall",
    N = nrow(m_data),
    AME = mfx_overall$AME,
    SE = mfx_overall$SE,
    CI_Lower = mfx_overall$lower,
    CI_Upper = mfx_overall$upper,
    P_Value = mfx_overall$p
  ))
  TRUE
}, error = function(e) {
  cat("Note: Could not calculate overall AME with interaction model.\n")
  cat("Error:", e$message, "\n\n")
  FALSE
})

# For each DR severity group - use a different approach
# Calculate AMEs by predicting with and without lapse for each group
for(dr_level in c("No_DR", "NPDR", "PDR")) {
  
  # Get subset of data for this DR severity
  subset_data <- m_data[m_data$dr_severity == dr_level, ]
  n_subset <- nrow(subset_data)
  
  # Create predictions with lapse = 0 and lapse = 1
  subset_data_0 <- subset_data
  subset_data_0$ever_lapse_binary <- 0
  
  subset_data_1 <- subset_data
  subset_data_1$ever_lapse_binary <- 1
  
  # Get predictions (probabilities)
  pred_0 <- predict(model_dr_interaction, newdata = subset_data_0, type = "response")
  pred_1 <- predict(model_dr_interaction, newdata = subset_data_1, type = "response")
  
  # Calculate individual-level effects
  individual_effects <- as.numeric(pred_1) - as.numeric(pred_0)
  
  # Calculate AME as weighted mean if we have weights, otherwise simple mean
  if("twang_att_w" %in% names(subset_data)) {
    # Use the weights for this subset
    subset_weights <- subset_data$twang_att_w
    
    # Check and ensure equal lengths
    if(length(individual_effects) != length(subset_weights)) {
      cat(paste("  Note: Adjusting for length mismatch in", dr_level, 
                "- effects:", length(individual_effects), 
                "weights:", length(subset_weights), "\n"))
      # Try to match lengths
      min_length <- min(length(individual_effects), length(subset_weights))
      individual_effects <- individual_effects[1:min_length]
      subset_weights <- subset_weights[1:min_length]
    }
    
    # Remove any NAs
    valid_idx <- !is.na(individual_effects) & !is.na(subset_weights)
    individual_effects_clean <- individual_effects[valid_idx]
    subset_weights_clean <- subset_weights[valid_idx]
    
    if(length(individual_effects_clean) > 0 && length(subset_weights_clean) > 0) {
      ame_value <- weighted.mean(individual_effects_clean, w = subset_weights_clean)
      # Weighted standard error
      weighted_var <- sum(subset_weights_clean * (individual_effects_clean - ame_value)^2) / sum(subset_weights_clean)
      se_value <- sqrt(weighted_var / length(individual_effects_clean))
    } else {
      cat("  Warning: No valid data after removing NAs, using unweighted mean\n")
      ame_value <- mean(individual_effects, na.rm = TRUE)
      se_value <- sd(individual_effects, na.rm = TRUE) / sqrt(sum(!is.na(individual_effects)))
    }
  } else {
    # Simple mean if no weights
    ame_value <- mean(individual_effects, na.rm = TRUE)
    se_value <- sd(individual_effects, na.rm = TRUE) / sqrt(sum(!is.na(individual_effects)))
  }
  
  # Calculate confidence intervals
  ci_lower <- ame_value - 1.96 * se_value
  ci_upper <- ame_value + 1.96 * se_value
  
  # Calculate p-value (two-sided test)
  z_stat <- ame_value / se_value
  p_value <- 2 * pnorm(-abs(z_stat))
  
  # Add to results
  ame_results <- rbind(ame_results, data.frame(
    DR_Severity = dr_level,
    N = n_subset,
    AME = ame_value,
    SE = se_value,
    CI_Lower = ci_lower,
    CI_Upper = ci_upper,
    P_Value = p_value
  ))
}

# Format for display
if(nrow(ame_results) > 0) {
  ame_display <- ame_results |>
    mutate(
      AME = round(AME, 4),
      SE = round(SE, 4),
      CI = paste0("(", round(CI_Lower, 4), ", ", round(CI_Upper, 4), ")"),
      P_Value = format.pval(P_Value, digits = 4, eps = 0.0001)
    ) |>
    select(DR_Severity, N, AME, SE, CI, P_Value)
  
  knitr::kable(ame_display,
               caption = "Average Marginal Effects of Lapsing on Vision Impairment by DR Severity",
               col.names = c("DR Severity", "N", "AME", "SE", "95% CI", "P-value"),
               row.names = FALSE,
               digits = 4)
  
  cat("\nNote: AME represents the average change in probability of vision impairment when lapsing occurs,")
  cat("\naveraged over the covariate distribution within each DR severity group.")
  cat("\nWeighted by IPTW weights where applicable.\n")
} else {
  cat("Could not calculate AMEs.\n")
}
```

## Visualization of Average Marginal Effects

```{r ame_visualization, fig.height=6, fig.width=10}
# Plot the AMEs from margins package
if(exists("ame_results") && nrow(ame_results) > 0) {
  # Exclude overall from plot, focus on DR severity groups
  plot_data_ame <- ame_results[ame_results$DR_Severity != "Overall", ]
  
  # Create bar plot comparing AME magnitudes
  ame_bar_plot <- ggplot(plot_data_ame, aes(x = reorder(DR_Severity, AME), y = AME, fill = DR_Severity)) +
    geom_col(alpha = 0.7) +
    geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper), 
                  width = 0.2, size = 1) +
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +
    coord_flip() +
    labs(title = "Magnitude of Lapse Effect Across DR Severity",
         subtitle = "Average marginal effects with 95% confidence intervals",
         x = "",
         y = "Average Marginal Effect") +
    theme_minimal() +
    theme(plot.title = element_text(size = 14, face = "bold"),
          axis.text = element_text(size = 11),
          axis.title = element_text(size = 12),
          legend.position = "none") +
    scale_fill_manual(values = c("No_DR" = "#1f77b4", 
                                 "NPDR" = "#ff7f0e", 
                                 "PDR" = "#d62728")) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.001),
                       limits = c(NA, 0.5)) +
    geom_text(aes(label = sprintf("%.3f", AME)),
              hjust = ifelse(plot_data_ame$AME > 0, -0.2, 1.2),
              size = 3.5)
  
  print(ame_bar_plot)
} else {
  cat("AME results not available for visualization.\n")
}
```

## Complete Coefficient Interpretation

```{r coefficient_interpretation}
# Extract all coefficients for complete interpretation
all_coefs <- summary_dr$coefficients

# Create interpretation table for main effects and interactions
main_dr_coefs <- c("ever_lapse_binary", "dr_severityNPDR", "dr_severityPDR",
                   dr_interaction_terms)

interp_data <- data.frame(
  Term = character(),
  Estimate = numeric(),
  Interpretation = character(),
  stringsAsFactors = FALSE
)

# Main effect of lapse
if("ever_lapse_binary" %in% rownames(all_coefs)) {
  interp_data <- rbind(interp_data, data.frame(
    Term = "ever_lapse_binary",
    Estimate = round(all_coefs["ever_lapse_binary", "Estimate"], 4),
    Interpretation = "Effect of lapsing for No DR patients (reference group)"
  ))
}

# DR severity main effects
if("dr_severityNPDR" %in% rownames(all_coefs)) {
  interp_data <- rbind(interp_data, data.frame(
    Term = "dr_severityNPDR",
    Estimate = round(all_coefs["dr_severityNPDR", "Estimate"], 4),
    Interpretation = "Baseline difference: NPDR vs No DR (among non-lapsers)"
  ))
}

if("dr_severityPDR" %in% rownames(all_coefs)) {
  interp_data <- rbind(interp_data, data.frame(
    Term = "dr_severityPDR",
    Estimate = round(all_coefs["dr_severityPDR", "Estimate"], 4),
    Interpretation = "Baseline difference: PDR vs No DR (among non-lapsers)"
  ))
}

# Interaction terms
for(term in dr_interaction_terms) {
  if(term %in% rownames(all_coefs)) {
    dr_level <- gsub("ever_lapse_binary:dr_severity", "", term)
    interp_data <- rbind(interp_data, data.frame(
      Term = term,
      Estimate = round(all_coefs[term, "Estimate"], 4),
      Interpretation = paste("Additional effect of lapsing in", dr_level, "vs No DR")
    ))
  }
}

knitr::kable(interp_data,
             caption = "Interpretation of Model Coefficients",
             row.names = FALSE)
```

# Treatment Type Interaction Analysis

## Treatment Type Interaction Model

```{r treatment_interaction_model}
# Fit the treatment type interaction model
model_treatment_interaction <- svyglm(
  formula = interaction_treatment_formula,
  design = survey_design_weighted,
  family = quasibinomial()
)

# Summary of treatment interaction model
summary_treatment <- summary(model_treatment_interaction)

# Extract interaction p-values for treatment model
treatment_interaction_terms <- grep("ever_lapse_binary:treatment_type", 
                                   names(coef(model_treatment_interaction)), value = TRUE)
treatment_interaction_pvals <- if(length(treatment_interaction_terms) > 0) {
  summary_treatment$coefficients[treatment_interaction_terms, "Pr(>|t|)"]
} else {
  numeric(0)
}

# Display results
tx_results <- data.frame(
  Term = treatment_interaction_terms,
  Coefficient = summary_treatment$coefficients[treatment_interaction_terms, "Estimate"],
  SE = summary_treatment$coefficients[treatment_interaction_terms, "Std. Error"],
  P_Value = round(treatment_interaction_pvals, 4),
  Significant = ifelse(treatment_interaction_pvals < 0.05, "Yes", "No")
)

knitr::kable(tx_results, caption = "Treatment Type Interaction Terms (Individual Coefficients)")
```

## Joint Test of Treatment Interaction Terms

```{r joint_treatment_test}
# Joint Wald test for treatment interactions
# H0: All interaction terms equal zero
# This tests whether the effect of lapsing is the same across all treatment types

if(length(treatment_interaction_terms) > 0) {
  # Create hypothesis strings for all interaction terms
  hypothesis_strings <- paste0(treatment_interaction_terms, " = 0")
  
  joint_test_treatment <- linearHypothesis(
    model_treatment_interaction,
    hypothesis_strings,
    vcov = vcov(model_treatment_interaction)
  )
  
  # Display joint test results
  joint_results_treatment <- data.frame(
    Test = "Joint interaction test",
    Chisq = round(joint_test_treatment$Chisq[2], 3),
    Df = joint_test_treatment$Df[2],
    P_Value = format.pval(joint_test_treatment$`Pr(>Chisq)`[2], digits = 4, eps = 0.0001)
  )
  
  knitr::kable(joint_results_treatment, 
               caption = "Joint Wald Test for Treatment Type Interactions",
               row.names = FALSE)
  
  # Interpret the joint test
  if(joint_test_treatment$`Pr(>Chisq)`[2] < 0.05) {
    cat("Joint test is significant: The effect of lapsing varies by treatment type\n")
  } else {
    cat("Joint test is not significant: The effect of lapsing is similar across treatment types\n")
  }
} else {
  cat("No interaction terms found for joint testing\n")
}
```

## Effect of Lapsing Within Each Treatment Type

```{r lapse_effects_by_treatment}
# Calculate the effect of lapsing within each treatment group
# Extract coefficients and variance-covariance matrix
coef_vals_tx <- coef(model_treatment_interaction)
vcov_mat_tx <- vcov(model_treatment_interaction)

# Initialize results
treatment_effects <- data.frame(
  Treatment_Type = c("no_treatment", "anti_VEGF", "PRP", "other_treatment"),
  Log_Odds = numeric(4),
  SE = numeric(4),
  stringsAsFactors = FALSE
)

# Effect for no_treatment (reference - just main effect)
treatment_effects$Log_Odds[1] <- coef_vals_tx["ever_lapse_binary"]
treatment_effects$SE[1] <- sqrt(vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary"])

# Effect for anti_VEGF (main + interaction)
if("ever_lapse_binary:treatment_typeanti_VEGF" %in% names(coef_vals_tx)) {
  treatment_effects$Log_Odds[2] <- coef_vals_tx["ever_lapse_binary"] + 
                                    coef_vals_tx["ever_lapse_binary:treatment_typeanti_VEGF"]
  treatment_effects$SE[2] <- sqrt(
    vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat_tx["ever_lapse_binary:treatment_typeanti_VEGF", "ever_lapse_binary:treatment_typeanti_VEGF"] +
    2 * vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary:treatment_typeanti_VEGF"]
  )
}

# Effect for PRP (main + interaction)
if("ever_lapse_binary:treatment_typePRP" %in% names(coef_vals_tx)) {
  treatment_effects$Log_Odds[3] <- coef_vals_tx["ever_lapse_binary"] + 
                                    coef_vals_tx["ever_lapse_binary:treatment_typePRP"]
  treatment_effects$SE[3] <- sqrt(
    vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat_tx["ever_lapse_binary:treatment_typePRP", "ever_lapse_binary:treatment_typePRP"] +
    2 * vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary:treatment_typePRP"]
  )
}

# Effect for other_treatment (main + interaction)
if("ever_lapse_binary:treatment_typeother_treatment" %in% names(coef_vals_tx)) {
  treatment_effects$Log_Odds[4] <- coef_vals_tx["ever_lapse_binary"] + 
                                    coef_vals_tx["ever_lapse_binary:treatment_typeother_treatment"]
  treatment_effects$SE[4] <- sqrt(
    vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat_tx["ever_lapse_binary:treatment_typeother_treatment", "ever_lapse_binary:treatment_typeother_treatment"] +
    2 * vcov_mat_tx["ever_lapse_binary", "ever_lapse_binary:treatment_typeother_treatment"]
  )
}

# Calculate CIs, ORs, and p-values
treatment_effects <- treatment_effects |>
  mutate(
    CI_Lower = Log_Odds - 1.96 * SE,
    CI_Upper = Log_Odds + 1.96 * SE,
    Odds_Ratio = exp(Log_Odds),
    Z_stat = Log_Odds / SE,
    P_Value = 2 * pnorm(-abs(Z_stat))
  ) |>
  mutate(
    Log_Odds = round(Log_Odds, 4),
    SE = round(SE, 4),
    CI_Lower = round(CI_Lower, 4),
    CI_Upper = round(CI_Upper, 4),
    Odds_Ratio = round(Odds_Ratio, 4),
    P_Value = format.pval(P_Value, digits = 4, eps = 0.0001)
  ) |>
  select(-Z_stat)

knitr::kable(treatment_effects,
             caption = "Effect of Lapsing Within Each Treatment Type",
             row.names = FALSE)
```

## Average Marginal Effects by Treatment Type

```{r margins_treatment}
# Calculate AMEs for each treatment type group
cat("Calculating Average Marginal Effects by treatment type...\n\n")

# Initialize results storage
ame_results_tx <- data.frame()

# For each treatment type
for(tx_type in c("no_treatment", "anti_VEGF", "PRP", "other_treatment")) {
  
  # Get subset of data for this treatment type
  subset_data_tx <- m_data[m_data$treatment_type == tx_type, ]
  n_subset_tx <- nrow(subset_data_tx)
  
  if(n_subset_tx > 0) {
    # Create predictions with lapse = 0 and lapse = 1
    subset_data_tx_0 <- subset_data_tx
    subset_data_tx_0$ever_lapse_binary <- 0
    
    subset_data_tx_1 <- subset_data_tx
    subset_data_tx_1$ever_lapse_binary <- 1
    
    # Get predictions (probabilities)
    pred_0_tx <- predict(model_treatment_interaction, newdata = subset_data_tx_0, type = "response")
    pred_1_tx <- predict(model_treatment_interaction, newdata = subset_data_tx_1, type = "response")
    
    # Calculate individual-level effects
    individual_effects_tx <- as.numeric(pred_1_tx) - as.numeric(pred_0_tx)
    
    # Calculate AME with weights if available
    if("twang_att_w" %in% names(subset_data_tx)) {
      subset_weights_tx <- subset_data_tx$twang_att_w
      
      # Ensure equal lengths and remove NAs
      valid_idx_tx <- !is.na(individual_effects_tx) & !is.na(subset_weights_tx)
      if(sum(valid_idx_tx) > 0) {
        ame_value_tx <- weighted.mean(individual_effects_tx[valid_idx_tx], 
                                      w = subset_weights_tx[valid_idx_tx])
        weighted_var_tx <- sum(subset_weights_tx[valid_idx_tx] * 
                              (individual_effects_tx[valid_idx_tx] - ame_value_tx)^2) / 
                          sum(subset_weights_tx[valid_idx_tx])
        se_value_tx <- sqrt(weighted_var_tx / sum(valid_idx_tx))
      } else {
        ame_value_tx <- mean(individual_effects_tx, na.rm = TRUE)
        se_value_tx <- sd(individual_effects_tx, na.rm = TRUE) / sqrt(sum(!is.na(individual_effects_tx)))
      }
    } else {
      ame_value_tx <- mean(individual_effects_tx, na.rm = TRUE)
      se_value_tx <- sd(individual_effects_tx, na.rm = TRUE) / sqrt(sum(!is.na(individual_effects_tx)))
    }
    
    # Calculate confidence intervals and p-value
    ci_lower_tx <- ame_value_tx - 1.96 * se_value_tx
    ci_upper_tx <- ame_value_tx + 1.96 * se_value_tx
    z_stat_tx <- ame_value_tx / se_value_tx
    p_value_tx <- 2 * pnorm(-abs(z_stat_tx))
    
    # Add to results
    ame_results_tx <- rbind(ame_results_tx, data.frame(
      Treatment_Type = tx_type,
      N = n_subset_tx,
      AME = ame_value_tx,
      SE = se_value_tx,
      CI_Lower = ci_lower_tx,
      CI_Upper = ci_upper_tx,
      P_Value = p_value_tx
    ))
  }
}

# Format for display
if(nrow(ame_results_tx) > 0) {
  ame_display_tx <- ame_results_tx |>
    mutate(
      AME = round(AME, 4),
      SE = round(SE, 4),
      CI = paste0("(", round(CI_Lower, 4), ", ", round(CI_Upper, 4), ")"),
      P_Value = format.pval(P_Value, digits = 4, eps = 0.0001)
    ) |>
    select(Treatment_Type, N, AME, SE, CI, P_Value)
  
  knitr::kable(ame_display_tx,
               caption = "Average Marginal Effects of Lapsing by Treatment Type",
               col.names = c("Treatment Type", "N", "AME", "SE", "95% CI", "P-value"),
               row.names = FALSE,
               digits = 4)
}
```

## Visualization of Treatment Type Effects

```{r treatment_visualization, fig.height=6, fig.width=10}
# Plot the AMEs by treatment type
if(exists("ame_results_tx") && nrow(ame_results_tx) > 0) {
  
  # Create bar plot comparing AME magnitudes
  ame_bar_plot_tx <- ggplot(ame_results_tx, 
                            aes(x = reorder(Treatment_Type, AME), y = AME, fill = Treatment_Type)) +
    geom_col(alpha = 0.7) +
    geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper), 
                  width = 0.2, size = 1) +
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +
    coord_flip() +
    labs(title = "Magnitude of Lapse Effect Across Treatment Types",
         subtitle = "Average marginal effects with 95% confidence intervals",
         x = "",
         y = "Average Marginal Effect") +
    theme_minimal() +
    theme(plot.title = element_text(size = 14, face = "bold"),
          axis.text = element_text(size = 11),
          axis.title = element_text(size = 12),
          legend.position = "none") +
    scale_fill_manual(values = c("no_treatment" = "#2ca02c",
                                 "anti_VEGF" = "#d62728", 
                                 "PRP" = "#ff7f0e", 
                                 "other_treatment" = "#9467bd")) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.001),
                       limits = c(NA, 0.5)) +
    geom_text(aes(label = sprintf("%.3f", AME)),
              hjust = ifelse(ame_results_tx$AME > 0, -0.2, 1.2),
              size = 3.5)
  
  print(ame_bar_plot_tx)
} else {
  cat("AME results by treatment type not available for visualization.\n")
}
```

# Summary

## Key Findings

### DR Severity Interaction
A formal interaction analysis provides evidence that **the effect of lapsing from care on vision impairment depends significantly on patients' baseline DR severity (joint interaction test p < 0.05).

### Substantive Results:

1. **Patients with No DR (n=16,130)**: Lapsing from care increases the odds of vision impairment by approximately 17% (OR = 1.17, log odds = 0.160). This effect is statistically significant.

2. **Patients with NPDR (n=5,695)**: Lapsing has a substantially stronger effect, increasing the odds of vision impairment by approximately 47% (OR = 1.47, log odds = 0.386). This effect is also statistically significant and notably larger than in the No DR group (although the error bars do cross over)

3. **Patients with PDR (n=3,187)**: Lapsing shows minimal effect on vision impairment risk (OR ≈ 1.01, log odds = 0.006), and this effect is not statistically significant.

### Response to Reviewer:

This analysis directly addresses the reviewer's concern about "inadequate subgroup testing" by:

- Providing formal statistical tests (joint Wald test) rather than relying on visual overlap alone
- Calculating group-specific effects with proper confidence intervals
- Demonstrating that the interaction is statistically significant (p < 0.05)
- Showing that subgroup effects are meaningfully different, not just statistically different

The significant interaction confirms that a "one-size-fits-all" interpretation of lapsing effects would be misleading. The surprising finding that PDR patients show essentially no harm from lapsing (OR ≈ 1.01) suggests we may need to **reconsider our conceptual understanding of lapsing in advanced disease**. While NPDR patients show substantial risk from care disruption, the null effect in PDR raises questions about whether our retention efforts should be differentially targeted based on disease severity.


