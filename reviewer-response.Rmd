---
title: "Reviewer Response Analysis"
author: "Erik Westlund"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 6
)

# Load required libraries and settings
source("settings.R")
source("functions.R")

# Load all required libraries
load_required_libraries()
```

# Data Preparation

```{r load_data}
# Load and prepare data
data_path <- file.path(s_root, "Gina's Project/df_Final_240909.csv")
data <- load_and_prepare_data(data_path)

# Apply the same exclusions as main analysis
m_data <- apply_exclusions(data)

print(sprintf("Total observations after exclusions: %d", nrow(m_data)))
print(sprintf("Total unique patients: %d", length(unique(m_data$e_mrn_deidentified))))
```

## Load IPTW Weights from Analysis

```{r twang_weights}
# Load cached results from the main analysis pipeline
cached_results <- load_cached_results("ps_results")

# Check if twang model exists in cached results
if(!"twang_gbm" %in% names(cached_results)) {
  stop("No cached twang model found. Please run analysis.Rmd first to generate IPTW weights.")
}

print("Loading cached twang model for IPTW weights...")
twang_model <- cached_results$twang_gbm$result

# Extract IPTW weights from twang model (same as in analysis.Rmd)
m_data$twang_att_w <- get.weights(twang_model, stop.method = "es.mean")

# Summary of weights
print("Weight distribution:")
summary(m_data$twang_att_w)
```

## Main Effect of Lapsing (IPTW-Weighted)

```{r main_effect}
# Run the main model with full covariates to get the lapse effect
# Using the same formula as analysisFormulaFull from functions.R
main_formula <- get_analysis_formulas()$full

# Create weighted survey design
survey_design_weighted <- svydesign(
  ids = ~e_mrn_deidentified,
  data = m_data,
  weights = ~twang_att_w
)

# Fit the main model
main_model <- svyglm(
  formula = main_formula,
  design = survey_design_weighted,
  family = quasibinomial()
)

# Extract lapse effect
coef_summary <- summary(main_model)$coefficients
lapse_est <- coef_summary["ever_lapse_binary", "Estimate"]
lapse_se <- coef_summary["ever_lapse_binary", "Std. Error"]
lapse_p <- coef_summary["ever_lapse_binary", "Pr(>|t|)"]

# Calculate confidence intervals
lapse_ci <- confint(main_model)["ever_lapse_binary", ]

# Create results table
lapse_results <- data.frame(
  Log_Odds = round(lapse_est, 4),
  Odds_Ratio = round(exp(lapse_est), 4),
  CI_Lower = round(lapse_ci[1], 4),
  CI_Upper = round(lapse_ci[2], 4),
  P_Value = format.pval(lapse_p, digits = 4, eps = 0.0001)
)

knitr::kable(lapse_results, 
             caption = "Effect of Lapsing on Vision Impairment (IPTW-Weighted)",
             row.names = FALSE)
```

# Reviewer Question 1: Subgroup Testing with Formal Interaction Terms

**Reviewer Comment:** "Inadequate Subgroup Testing: Visual forest‑plot overlap doesn't prove consistent effects across subgroups (e.g., PDR+anti‑VEGF vs. PDR+PRP). Without formal interaction testing, subgroup claims lack statistical backing."

**Response:** We perform formal interaction testing using two models:
1. Interaction between lapse status and DR severity
2. Interaction between lapse status and treatment type

## Create Analysis Variables

```{r create_variables}
# Create the treatment type variable and properly labeled DR severity
m_data <- m_data |>
  mutate(
    treatment_type = case_when(
      anti_VEGF == 1 ~ "anti_VEGF",
      PRP_flag == 1 ~ "PRP",
      other_inject == 1 | focal_laser_flag == 1 ~ "other_treatment",
      TRUE ~ "no_treatment"
    ),
    treatment_type = factor(treatment_type, 
                           levels = c("no_treatment", "anti_VEGF", "PRP", "other_treatment")),
    # Create labeled DR severity factor for clearer interaction terms
    dr_severity = factor(person_dr,
                        levels = c(0, 1, 2),
                        labels = c("No_DR", "NPDR", "PDR"))
  )

# Check distribution of treatment types
print("Treatment Type Distribution:")
table(m_data$treatment_type)

# Display DR severity coding and distribution
print("DR Severity Distribution:")
table(m_data$dr_severity)
```

## Variable Definitions

```{r variable_definitions}
# Create a reference table for all key variables
variable_definitions <- data.frame(
  Variable = c("ever_lapse_binary", "outcome_va_vi_binary", "dr_severity", 
               "treatment_type", "person_dr", "person_dr_severity"),
  Type = c("Binary", "Binary", "Factor", "Factor", "Numeric", "Numeric"),
  Values = c("0 = No lapse, 1 = Lapsed from care",
             "0 = No vision impairment, 1 = Vision impairment (VA ≥ 0.3 logMAR)",
             "No_DR, NPDR, PDR (labeled factor for interactions)",
             "no_treatment, anti_VEGF, PRP, other_treatment",
             "0 = No DR, 1 = NPDR, 2 = PDR (numeric coding)",
             "0 = No DR, 1 = Mild NPDR, 2 = Moderate NPDR, 3 = Severe NPDR, 4 = PDR"),
  stringsAsFactors = FALSE
)

knitr::kable(variable_definitions, 
             caption = "Key Variable Definitions",
             col.names = c("Variable", "Type", "Possible Values/Coding"))
```

## Define Model Formulas

```{r define_formulas}
# Define the base formula (same as analysisFormulaFull but without the outcome)
base_covariates <- c(
  "gender_cat",
  "race_ethnic_cat", 
  "insurance_cat",
  "age_cat",
  "CCI",
  "DCSI",
  "other_inject",
  "anti_VEGF",
  "focal_laser_flag",
  "PRP_flag",
  "glaucoma_bef_hitplus_cat",
  "otherretina_bef_hitplus_cat",
  "catsurg_before_hitplus_cat"
)

# Model 1: Interaction with DR severity
# dr_severity: No_DR, NPDR, PDR
interaction_dr_formula <- as.formula(paste(
  "outcome_va_vi_binary ~ ever_lapse_binary * dr_severity +",
  paste(base_covariates, collapse = " + ")
))

# Model 2: Interaction with treatment type
interaction_treatment_formula <- as.formula(paste(
  "outcome_va_vi_binary ~ ever_lapse_binary * treatment_type +",
  paste(base_covariates, collapse = " + ")
))

print("DR Interaction Formula:")
print(interaction_dr_formula)

print("Treatment Interaction Formula:")
print(interaction_treatment_formula)
```

## Run Interaction Models (IPTW Weighted)

```{r interaction_models, results='asis'}
# Store results for weighted analyses only
interaction_results <- list()

# Create weighted survey design
survey_design_weighted <- svydesign(
  ids = ~e_mrn_deidentified,
  data = m_data,
  weights = ~twang_att_w
)

### DR Severity Interaction Model

```{r dr_interaction}
# Fit Model 1: DR severity interaction
model_dr_interaction <- svyglm(
  formula = interaction_dr_formula,
  design = survey_design_weighted,
  family = quasibinomial()
)

# Summary of DR interaction model
summary_dr <- summary(model_dr_interaction)

# Extract interaction p-values for DR model
dr_interaction_terms <- grep("ever_lapse_binary:dr_severity", 
                            names(coef(model_dr_interaction)), value = TRUE)
dr_interaction_pvals <- if(length(dr_interaction_terms) > 0) {
  summary_dr$coefficients[dr_interaction_terms, "Pr(>|t|)"]
} else {
  numeric(0)
}

# Display results
dr_results <- data.frame(
  Term = dr_interaction_terms,
  Coefficient = summary_dr$coefficients[dr_interaction_terms, "Estimate"],
  SE = summary_dr$coefficients[dr_interaction_terms, "Std. Error"],
  P_Value = round(dr_interaction_pvals, 4),
  Significant = ifelse(dr_interaction_pvals < 0.05, "Yes", "No")
)

knitr::kable(dr_results, caption = "DR Severity Interaction Terms (Individual Coefficients)")
```

## Understanding the Interaction Model

In the interaction model `outcome ~ lapse * dr_severity`, the coefficients represent:

- **Main effect of lapse (β₁)**: Effect of lapsing for the reference group (No DR)
- **Main effects of DR severity (β₂, β₃)**: Baseline differences in risk for NPDR/PDR vs No DR among non-lapsers
- **Interaction terms (β₄, β₅)**: How much the effect of lapsing differs in NPDR/PDR compared to No DR

The actual effect of lapsing within each DR group is:
- **No DR**: β₁
- **NPDR**: β₁ + β₄ 
- **PDR**: β₁ + β₅

## Joint Test of Interaction Terms

```{r joint_interaction_test}

# Joint Wald test: Are the interaction terms jointly significant?
# H0: ever_lapse_binary:dr_severityNPDR = 0 AND ever_lapse_binary:dr_severityPDR = 0
# This tests whether the effect of lapsing is the same across all DR severity levels

joint_test <- linearHypothesis(
  model_dr_interaction,
  c("ever_lapse_binary:dr_severityNPDR = 0",
    "ever_lapse_binary:dr_severityPDR = 0"),
  vcov = vcov(model_dr_interaction)
)

# Display joint test results
joint_results <- data.frame(
  Test = "Joint interaction test",
  Chisq = round(joint_test$Chisq[2], 3),
  Df = joint_test$Df[2],
  P_Value = format.pval(joint_test$`Pr(>Chisq)`[2], digits = 4, eps = 0.0001)
)

knitr::kable(joint_results, 
             caption = "Joint Wald Test for DR Severity Interactions",
             row.names = FALSE)

# Interpret the joint test
if(joint_test$`Pr(>Chisq)`[2] < 0.05) {
  print("Joint test is significant: The effect of lapsing varies by DR severity")
} else {
  print("Joint test is not significant: The effect of lapsing is similar across DR severity levels")
}
```

## Effect of Lapsing Within Each DR Severity Group

```{r lapse_effects_by_dr}

# Method 1: Use emmeans WITHOUT nuisance factors for true marginalization
# Increase reference grid limit to handle the full factorial
emm_options(rg.limit = 200000)  # Increase limit to handle large reference grid

# Calculate marginal means - this will average over all covariate combinations
emm <- emmeans(model_dr_interaction, 
               ~ ever_lapse_binary | dr_severity)

# Get contrasts: effect of lapse (1 vs 0) within each DR severity
lapse_contrasts <- contrast(emm, method = "revpairwise", by = "dr_severity")

# Convert to data frame and clean up
lapse_effects <- as.data.frame(lapse_contrasts)

# Create clean results table
lapse_effects_table <- data.frame(
  DR_Severity = lapse_effects$dr_severity,
  Log_Odds = round(lapse_effects$estimate, 4),
  SE = round(lapse_effects$SE, 4),
  CI_Lower = round(lapse_effects$estimate - 1.96 * lapse_effects$SE, 4),
  CI_Upper = round(lapse_effects$estimate + 1.96 * lapse_effects$SE, 4),
  Odds_Ratio = round(exp(lapse_effects$estimate), 4),
  P_Value = format.pval(lapse_effects$p.value, digits = 4, eps = 0.0001)
)

knitr::kable(lapse_effects_table,
             caption = "Effect of Lapsing Within Each DR Severity Group",
             row.names = FALSE)
```

## Alternative: Manual Calculation of Lapse Effects

```{r manual_lapse_effects}
# Note: This manual calculation should produce identical results to emmeans above
# If emmeans still has issues, we can calculate the effects manually
# Extract coefficients and variance-covariance matrix
coef_vals <- coef(model_dr_interaction)
vcov_mat <- vcov(model_dr_interaction)

# Define the linear combinations for each DR group
# Effect in No DR: just the main effect
# Effect in NPDR: main effect + NPDR interaction
# Effect in PDR: main effect + PDR interaction

# Create contrast matrix
contrast_names <- c("Lapse effect in No DR",
                    "Lapse effect in NPDR", 
                    "Lapse effect in PDR")

# Initialize results
manual_effects <- data.frame(
  DR_Severity = c("No_DR", "NPDR", "PDR"),
  Log_Odds = numeric(3),
  SE = numeric(3),
  stringsAsFactors = FALSE
)

# Effect for No DR (just main effect)
manual_effects$Log_Odds[1] <- coef_vals["ever_lapse_binary"]
manual_effects$SE[1] <- sqrt(vcov_mat["ever_lapse_binary", "ever_lapse_binary"])

# Effect for NPDR (main + interaction)
if("ever_lapse_binary:dr_severityNPDR" %in% names(coef_vals)) {
  manual_effects$Log_Odds[2] <- coef_vals["ever_lapse_binary"] + 
                                 coef_vals["ever_lapse_binary:dr_severityNPDR"]
  # SE calculation for sum of coefficients
  manual_effects$SE[2] <- sqrt(
    vcov_mat["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat["ever_lapse_binary:dr_severityNPDR", "ever_lapse_binary:dr_severityNPDR"] +
    2 * vcov_mat["ever_lapse_binary", "ever_lapse_binary:dr_severityNPDR"]
  )
}

# Effect for PDR (main + interaction)
if("ever_lapse_binary:dr_severityPDR" %in% names(coef_vals)) {
  manual_effects$Log_Odds[3] <- coef_vals["ever_lapse_binary"] + 
                                 coef_vals["ever_lapse_binary:dr_severityPDR"]
  # SE calculation for sum of coefficients
  manual_effects$SE[3] <- sqrt(
    vcov_mat["ever_lapse_binary", "ever_lapse_binary"] +
    vcov_mat["ever_lapse_binary:dr_severityPDR", "ever_lapse_binary:dr_severityPDR"] +
    2 * vcov_mat["ever_lapse_binary", "ever_lapse_binary:dr_severityPDR"]
  )
}

# Calculate CIs and OR
manual_effects <- manual_effects |>
  mutate(
    CI_Lower = Log_Odds - 1.96 * SE,
    CI_Upper = Log_Odds + 1.96 * SE,
    Odds_Ratio = exp(Log_Odds),
    # Calculate p-values (two-sided test)
    Z_stat = Log_Odds / SE,
    P_Value = 2 * pnorm(-abs(Z_stat))
  ) |>
  mutate(
    Log_Odds = round(Log_Odds, 4),
    SE = round(SE, 4),
    CI_Lower = round(CI_Lower, 4),
    CI_Upper = round(CI_Upper, 4),
    Odds_Ratio = round(Odds_Ratio, 4),
    P_Value = format.pval(P_Value, digits = 4, eps = 0.0001)
  ) |>
  select(-Z_stat)

knitr::kable(manual_effects,
             caption = "Effect of Lapsing Within Each DR Severity Group (Manual Calculation)",
             row.names = FALSE)

# Verify that emmeans and manual calculations match
if(exists("lapse_effects_table") && nrow(lapse_effects_table) > 0) {
  # Compare the two methods
  comparison <- data.frame(
    DR_Severity = manual_effects$DR_Severity,
    Emmeans_LogOdds = lapse_effects_table$Log_Odds,
    Manual_LogOdds = manual_effects$Log_Odds,
    Difference = abs(lapse_effects_table$Log_Odds - manual_effects$Log_Odds)
  )
  
  if(max(comparison$Difference) < 0.001) {
    cat("\n✓ Verification: Emmeans and manual calculations produce identical results (differences < 0.001)\n")
  } else {
    cat("\n⚠ Warning: Some differences between emmeans and manual calculations:\n")
    print(comparison)
  }
} else {
  cat("\nNote: Using manual calculation method as emmeans encountered issues with reference grid size.\n")
}
```

## Visualization of Interaction Effects

```{r visualize_interactions, fig.height=6, fig.width=10}
# Use the manual_effects data for visualization
plot_data <- manual_effects

# Bar chart showing magnitude of effects with error bars
p_magnitude <- ggplot(plot_data, aes(x = DR_Severity, y = Log_Odds, fill = DR_Severity)) +
  geom_col(alpha = 0.7) +
  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper), 
                width = 0.2, size = 1) +
  geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +
  labs(title = "Magnitude of Lapse Effect Across DR Severity",
       subtitle = "Note: Confidence intervals for No DR and NPDR overlap",
       x = "DR Severity",
       y = "Log Odds (Effect Size)") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12),
        legend.position = "none") +
  scale_fill_manual(values = c("No_DR" = "#1f77b4", 
                               "NPDR" = "#ff7f0e", 
                               "PDR" = "#d62728")) +
  geom_text(aes(label = sprintf("OR: %.2f", Odds_Ratio)),
            vjust = ifelse(plot_data$Log_Odds > 0, -1, 1.5),
            size = 4)

print(p_magnitude)
```

## Predicted Probabilities and Differences by Lapse Status

```{r probability_table_emmeans}
# Use emmeans to get predicted probabilities for each combination
# WITHOUT nuisance specification for TRUE marginalization

# IMPORTANT: How emmeans works without nuisance specification:
# - It creates a reference grid with all unique combinations of covariates
# - Then averages predictions across this grid
# - This gives us the AVERAGE predicted probability across all covariate patterns
# - This IS true marginalization over the covariate distribution

# Increase reference grid limit to handle all combinations
emm_options(rg.limit = 200000)

# Get predicted probabilities on the response scale
# This will average over all covariate combinations
emm_probs <- emmeans(model_dr_interaction, 
                     ~ ever_lapse_binary | dr_severity,
                     type = "response")

# Show what emmeans is doing
cat("EMmeans is averaging over all covariate combinations in the reference grid\n")
cat("Reference grid size information:\n")
print(str(emm_probs@grid))
cat("\n")

# Convert to data frame for manipulation
prob_summary <- as.data.frame(emm_probs)

# Create a clean table with probabilities for each group
prob_table <- data.frame(
  DR_Severity = rep(unique(prob_summary$dr_severity), each = 2),
  Lapse_Status = rep(c("No Lapse", "Lapse"), length(unique(prob_summary$dr_severity))),
  Probability = prob_summary$prob,
  SE = prob_summary$SE,
  Lower_CI = prob_summary$asymp.LCL,
  Upper_CI = prob_summary$asymp.UCL
)

# Calculate differences manually from the emmeans object
prob_contrasts <- contrast(emm_probs, method = "revpairwise", by = "dr_severity")
prob_diff_emmeans <- as.data.frame(prob_contrasts)

# Create final table combining probabilities and differences
final_prob_table <- data.frame(
  DR_Severity = c("No_DR", "NPDR", "PDR"),
  Prob_No_Lapse = prob_table$Probability[prob_table$Lapse_Status == "No Lapse"],
  Prob_Lapse = prob_table$Probability[prob_table$Lapse_Status == "Lapse"],
  Difference = prob_diff_emmeans$estimate,
  CI_Lower = prob_diff_emmeans$asymp.LCL,
  CI_Upper = prob_diff_emmeans$asymp.UCL,
  P_Value = prob_diff_emmeans$p.value
)

# Format the table for display
display_table <- final_prob_table |>
  mutate(
    Prob_No_Lapse = round(Prob_No_Lapse, 3),
    Prob_Lapse = round(Prob_Lapse, 3),
    Difference = round(Difference, 3),
    CI = paste0("(", round(CI_Lower, 3), ", ", round(CI_Upper, 3), ")"),
    P_Value = format.pval(P_Value, digits = 3, eps = 0.001)
  ) |>
  select(DR_Severity, Prob_No_Lapse, Prob_Lapse, Difference, CI, P_Value)

knitr::kable(display_table,
             caption = "Predicted Probability of Vision Impairment by DR Severity and Lapse Status (Averaged Over All Covariate Patterns)",
             col.names = c("DR Severity", "P(VI | No Lapse)", "P(VI | Lapse)", 
                          "Difference", "95% CI", "P-value"),
             row.names = FALSE,
             digits = 3)
```

## Alternative: Manual Verification of Average Marginal Effects

```{r true_marginal_effects}
# If you want TRUE marginalization (averaging over the distribution of covariates),
# we need to calculate predictions for every observation and then average

cat("Calculating average marginal effects by averaging over all observations...\n\n")

# For each DR severity group, calculate the average effect
marginal_effects <- data.frame(
  DR_Severity = c("No_DR", "NPDR", "PDR"),
  Avg_Prob_No_Lapse = numeric(3),
  Avg_Prob_Lapse = numeric(3),
  Difference = numeric(3),
  SE = numeric(3)
)

for(i in 1:3) {
  dr_level <- c("No_DR", "NPDR", "PDR")[i]
  
  # Get subset of data for this DR severity
  subset_data <- m_data[m_data$dr_severity == dr_level, ]
  
  # Predict for everyone with lapse = 0
  subset_data_0 <- subset_data
  subset_data_0$ever_lapse_binary <- 0
  pred_0 <- predict(model_dr_interaction, newdata = subset_data_0, type = "response")
  
  # Predict for everyone with lapse = 1
  subset_data_1 <- subset_data
  subset_data_1$ever_lapse_binary <- 1
  pred_1 <- predict(model_dr_interaction, newdata = subset_data_1, type = "response")
  
  # Calculate average probabilities
  marginal_effects$Avg_Prob_No_Lapse[i] <- mean(as.numeric(pred_0), na.rm = TRUE)
  marginal_effects$Avg_Prob_Lapse[i] <- mean(as.numeric(pred_1), na.rm = TRUE)
  marginal_effects$Difference[i] <- marginal_effects$Avg_Prob_Lapse[i] - marginal_effects$Avg_Prob_No_Lapse[i]
  
  # Bootstrap or delta method for SE would go here
  # For now, using a rough approximation
  marginal_effects$SE[i] <- sd(as.numeric(pred_1) - as.numeric(pred_0), na.rm = TRUE) / sqrt(nrow(subset_data))
}

# Format for display
marginal_display <- marginal_effects |>
  mutate(
    Avg_Prob_No_Lapse = round(Avg_Prob_No_Lapse, 3),
    Avg_Prob_Lapse = round(Avg_Prob_Lapse, 3),
    Difference = round(Difference, 3),
    CI_Lower = round(Difference - 1.96 * SE, 3),
    CI_Upper = round(Difference + 1.96 * SE, 3),
    CI = paste0("(", CI_Lower, ", ", CI_Upper, ")")
  ) |>
  select(DR_Severity, Avg_Prob_No_Lapse, Avg_Prob_Lapse, Difference, CI)

knitr::kable(marginal_display,
             caption = "Average Marginal Effects: Predicted Probabilities Averaged Over Observed Covariate Distribution",
             col.names = c("DR Severity", "Avg P(VI | No Lapse)", "Avg P(VI | Lapse)", 
                          "Difference", "95% CI"),
             row.names = FALSE,
             digits = 3)

cat("\nNote: The 'at reference/mean' table shows predictions for a typical patient.")
cat("\nThe 'average marginal effects' table averages predictions across all patients in each DR group.")
cat("\nThe difference represents how these approaches handle heterogeneity in the covariates.\n")
```

## Visualization of Probability Differences

```{r probability_differences_plot, fig.height=5, fig.width=8}
# Use the emmeans-based differences for plotting
plot_data_prob <- final_prob_table

# Plot the probability differences
prob_diff_plot <- ggplot(plot_data_prob, aes(x = DR_Severity, y = Difference)) +
  geom_point(size = 5, color = "darkblue") +
  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper), 
                width = 0.15, size = 1.2, color = "darkblue") +
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5, color = "gray50") +
  labs(title = "Difference in Probability of Vision Impairment: Lapsers vs Non-Lapsers",
       subtitle = "Average marginal effect of lapsing on probability scale with 95% CIs",
       x = "DR Severity",
       y = "Probability Difference") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 12)) +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001)) +
  # Add annotations for sample sizes
  annotate("text", x = 1, y = min(plot_data_prob$CI_Lower) - 0.01, 
           label = "n=16,130", size = 3.5, color = "gray50") +
  annotate("text", x = 2, y = min(plot_data_prob$CI_Lower) - 0.01, 
           label = "n=5,695", size = 3.5, color = "gray50") +
  annotate("text", x = 3, y = min(plot_data_prob$CI_Lower) - 0.01, 
           label = "n=3,187", size = 3.5, color = "gray50")

print(prob_diff_plot)
```

## Complete Coefficient Interpretation

```{r coefficient_interpretation}
# Extract all coefficients for complete interpretation
all_coefs <- summary_dr$coefficients

# Create interpretation table for main effects and interactions
main_dr_coefs <- c("ever_lapse_binary", "dr_severityNPDR", "dr_severityPDR",
                   dr_interaction_terms)

interp_data <- data.frame(
  Term = character(),
  Estimate = numeric(),
  Interpretation = character(),
  stringsAsFactors = FALSE
)

# Main effect of lapse
if("ever_lapse_binary" %in% rownames(all_coefs)) {
  interp_data <- rbind(interp_data, data.frame(
    Term = "ever_lapse_binary",
    Estimate = round(all_coefs["ever_lapse_binary", "Estimate"], 4),
    Interpretation = "Effect of lapsing for No DR patients (reference group)"
  ))
}

# DR severity main effects
if("dr_severityNPDR" %in% rownames(all_coefs)) {
  interp_data <- rbind(interp_data, data.frame(
    Term = "dr_severityNPDR",
    Estimate = round(all_coefs["dr_severityNPDR", "Estimate"], 4),
    Interpretation = "Baseline difference: NPDR vs No DR (among non-lapsers)"
  ))
}

if("dr_severityPDR" %in% rownames(all_coefs)) {
  interp_data <- rbind(interp_data, data.frame(
    Term = "dr_severityPDR",
    Estimate = round(all_coefs["dr_severityPDR", "Estimate"], 4),
    Interpretation = "Baseline difference: PDR vs No DR (among non-lapsers)"
  ))
}

# Interaction terms
for(term in dr_interaction_terms) {
  if(term %in% rownames(all_coefs)) {
    dr_level <- gsub("ever_lapse_binary:dr_severity", "", term)
    interp_data <- rbind(interp_data, data.frame(
      Term = term,
      Estimate = round(all_coefs[term, "Estimate"], 4),
      Interpretation = paste("Additional effect of lapsing in", dr_level, "vs No DR")
    ))
  }
}

knitr::kable(interp_data,
             caption = "Interpretation of Model Coefficients",
             row.names = FALSE)
```

# Summary

## Key Findings

A formal interaction analysis provides evidence that **==he effect of lapsing from care on vision impairment depends significantly on patients' baseline DR severity (joint interaction test p < 0.05).

### Substantive Results:

1. **Patients with No DR (n=16,130)**: Lapsing from care increases the odds of vision impairment by approximately 17% (OR = 1.17, log odds = 0.160). This effect is statistically significant.

2. **Patients with NPDR (n=5,695)**: Lapsing has a substantially stronger effect, increasing the odds of vision impairment by approximately 47% (OR = 1.47, log odds = 0.386). This effect is also statistically significant and notably larger than in the No DR group (although the error bars do cross over)

3. **Patients with PDR (n=3,187)**: Lapsing shows minimal effect on vision impairment risk (OR ≈ 1.01, log odds = 0.006), and this effect is not statistically significant.

### Response to Reviewer:

This analysis directly addresses the reviewer's concern about "inadequate subgroup testing" by:

- Providing formal statistical tests (joint Wald test) rather than relying on visual overlap alone
- Calculating group-specific effects with proper confidence intervals
- Demonstrating that the interaction is statistically significant (p < 0.05)
- Showing that subgroup effects are meaningfully different, not just statistically different

The significant interaction confirms that a "one-size-fits-all" interpretation of lapsing effects would be misleading. The surprising finding that PDR patients show essentially no harm from lapsing (OR ≈ 1.01) suggests we may need to **reconsider our conceptual understanding of lapsing in advanced disease**. While NPDR patients show substantial risk from care disruption, the null effect in PDR raises questions about whether our retention efforts should be differentially targeted based on disease severity.


