---
title: "Lapse & Vision Loss PS Analysis"
author: "Erik Westlund"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source("settings.R")

library(readr)
library(dplyr)
library(kableExtra)
library(purrr)
library(gee)
library(geepack)
library(ggplot2)
library(MatchIt)
library(twang)
library(survey)
library(sandwich)
library(clubSandwich)

shouldCache <- TRUE

data <- readr::read_csv(file.path(s_root, "Gina's Project/df_Final_240909.csv")) |> 
  mutate(
    outcome_va_vi = outcome_VA_logMAR >= 0.3,
    outcome_va_blind = outcome_VA_logMAR >= 1,
    outcome_va_vi_binary = if_else(outcome_va_vi, 1, 0),
    outcome_va_blind_binary = if_else(outcome_va_blind, 1, 0),
    ever_lapse_cat = factor(person_ever_lapse),
    ever_lapse_binary = if_else(ever_lapse_cat == TRUE, 1, 0),
    MRN = dplyr::min_rank(e_mrn_deidentified),
    gender_cat = factor(gender),
    race_ethnic_cat = factor(race_ethnicity_gp),
    insurance_cat = factor(insurance_gp),
    age_cat = cut(age, breaks = c(0, 20, 45, 65, Inf), laebsl = c("0-20", "21-45", "46-65", "65+")),
    person_dr = case_when(
      No_DR == TRUE ~ 0,
      NPDR == "Mild" ~ 1,
      NPDR == "Moderate" ~ 1,
      NPDR == "Severe" ~ 1,
      PDR == "Present" ~ 2,
    ),
    person_dr_severity = case_when(
      No_DR == TRUE ~ 0,
      NPDR == "Mild" ~ 1,
      NPDR == "Moderate" ~ 2,
      NPDR == "Severe" ~ 3,
      PDR == "Present" ~ 4,
    ),
    person_ever_treat = case_when(
      other_inject == 0 & anti_VEGF == 0 & focal_laser_flag == 0 & PRP_flag == 0 ~ FALSE,
      other_inject == 1 | anti_VEGF == 1 | focal_laser_flag == 1 | PRP_flag == 1 ~ TRUE
    ),
    glaucoma_bef_hitplus_cat = case_when(
      Glaucoma_bef_hitplus != "Present" | is.na(Glaucoma_bef_hitplus) ~ FALSE,
      Glaucoma_bef_hitplus == "Present" ~ TRUE
    ),
    glaucoma_after_hitplus_cat = case_when(
      Glaucoma_after_hitplus != "Present" | is.na(Glaucoma_after_hitplus) ~ FALSE,
      Glaucoma_after_hitplus == "Present" ~ TRUE
    ),
    otherretina_bef_hitplus_cat = case_when(
      Otherretina_bef_hitplus != "Present" | is.na(Otherretina_bef_hitplus) ~ FALSE,
      Otherretina_bef_hitplus == "Present" ~ TRUE
    ),
    glaucoma_after_hitplus_cat = case_when(
      Otherretina_after_hitplus != "Present" | is.na(Otherretina_after_hitplus) ~ FALSE,
      Otherretina_after_hitplus == "Present" ~ TRUE
    ),
    other_inject = factor(other_inject),
    anti_VEGF = factor(anti_VEGF),
    focal_laser_flag = factor(focal_laser_flag),
    PRP_flag = factor(PRP_flag),
    glaucoma_bef_hitplus_cat = factor(glaucoma_bef_hitplus_cat),
    otherretina_bef_hitplus_cat = factor(otherretina_bef_hitplus_cat),
    catsurg_before_hitplus_cat = factor(cataract_surgery_bef_hitplus)
  )

save_og_image <- function(plot, filename, width=800, height=1000) {
  png(filename=filename, width=width, height=height)
  plot
  dev.off()
} 

```

## Introduction

* `Treatment`: We consider here the "treatment" to be having a lapsed episode within our observation window.
* `Outcome`: We want to estimate the effect of the treatment on vision loss, measured separately as vision impairment and blindness.
* `Estimand`: We will estimate the ATT, or average treatment effect in the treated. 

In summary, we will attempt to estimate the effect of lapsing vs. not lapsing among those who lapsed. Put differently, one could think of this as the impact of attending clinic, counter to fact (lapsing), on vision impairment.

## Process

We will use propensity score matching techniques to estimate the probability of treatment (i.e., the probability of lapsing), given a vector of covariates. These covariates must be measured before treatment. We will then use these probabilities, or propensity scores, to construct a cohort of patients assembled or weighted such that it allows for the estimation of the desired estimand (here, the `ATT`).

Since we will be estimating the `ATT`, all patients who lapsed will be kept in the study. We will use various techniques to choose a matched cohort of patients, with the end goal of matching lapsers with patients who do not lapse, despite having a similar propensity to do so.

## Issues

10 People are missing CCI and DCSI:

```{r cci}
missing <- data |> 
  select(e_mrn_deidentified, CCI, DCSI) |> 
  filter(is.na(CCI) | is.na(DCSI))

missing |> count()
missing |> kable()

```

We will proceed with a data set that drops those patients.

```{r get_m_data}
m_data <- data |> filter(
  !is.na(!CCI) & !is.na(DCSI)
)

m_data |> count()
```

We will model `p(lapse)` using this formula:

```{r init_ps, echo = FALSE}
matchingFormula <- as.formula("ever_lapse_binary ~ 
  baseline_VA_logMAR +
  gender_cat +
  race_ethnic_cat +
  insurance_cat +
  age_cat +
  CCI +
  DCSI +
  other_inject +
  anti_VEGF +
  focal_laser_flag +
  PRP_flag +
  glaucoma_bef_hitplus_cat +
  otherretina_bef_hitplus_cat +
  catsurg_before_hitplus_cat")

print(matchingFormula)

```

## Initial Imbalance

We first want to assess the imbalance before weighting or matching to get a sense for how imbalanced our sample is.

```{r initial_imbalance}
m.initialImbalance <- matchit(
    formula = matchingFormula,
    data = m_data,
    method = NULL,
    distance = "glm" 
  )
```

```{r initial_imablance_img, echo=FALSE}

save_og_image(
  plot = plot(summary(m.initialImbalance), main="Summary of Initial Imbalance", sub="distance = p(lapse)"),
  filename = "images/m.initialImbalance_summary.png",
  width = 800,
  height = 1000
)
```

![Initial Imbalance](images/m.initialImbalance_summary.png)

A rule of thumb is <0.1 SMD is good, < 0.15 is acceptable, and over that is problematic.

Accounting:

* 25 measures
* 13 > 0.1


## Propensity Score Construction

Warning: there are fewer controls that treated unit, so 1:1 matching for the ATT is not possible; must match with replacement.

### K:1 nearest neighbor matching, GLM (logit) distance

```{r match_it_f, echo=FALSE}

run_match_it <- function(data, formula, replace=TRUE, estimate="ATT") {
  results <- list()
  
  designs <- c(
    list(
      method="nearest",
      distance="glm",
      link="logit"
    ),
    list(
      method="nearest",
      distance="gam"
    ),
    list(
      method="nearest",
      distance="gbm"
    ),
    list(

    
    
  )
  
}

```


```{r match_1, cache=shouldCache}
m.nearest_glm <- matchit(
  formula = matchingFormula,
  method="nearest",
  distance = "glm",
  replace = TRUE,
  estimate = "ATT",
  data = m_data
)
```
```{r match_1_save_images, echo=FALSE}
save_og_image(
  plot = plot(summary(m.nearest_glm), main="Summary of Post-matching Balance (K:1 Matching using logit)", sub="distance = p(lapse)"),
  filename = "images/m.nearest_glm_summary.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="jitter", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_glm_common_support.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="qq", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_glm_qq.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="ecdf", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_glm_ecdf.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="density", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_glm_density.png",
  width = 800,
  height = 1000
)

```

#### Diagnostics

##### Balance

![Post-matching (K:1 using Logit) Imbalance](images/m.nearest_glm_common_support.png)

Accounting:

* 25 measures
* 25 under 0.1 ASMD
* 24 under 0.05 ASMD

This is a promising start.

##### Common Support/Equipoise

![Post-matching (K:1 using Logit) Common Support](images/m.nearest_glm_summary.png)

We see all treatment are matched, and there is good common support. This implies that for each lapsed patient, there are similar people who did not lapse.


### K:1 nearest neighbor matching, Mahalanobis distance

This is a different approach, using the mahalanobis distance to match T/C patients. This accounts for the scale of measures and their correlations. Patients with the small distance between them are good matches.

Note the larger circles near the boundaries. These indicate controls who were matched multiple times.

```{r match_2, cache=shouldCache}
m.nearest_mahalanobis <- matchit(
  formula = matchingFormula,
  method="nearest",
  distance = "mahalanobis",
  replace = TRUE,
  estimate = "ATT",
  data = m_data
)
```
```{r match_2_save_images, echo=FALSE}
save_og_image(
  plot = plot(summary(m.nearest_glm), main="Summary of Post-matching Balance (K:1 Matching using Mahalanobis distance)", sub="distance = p(lapse)"),
  filename = "images/m.nearest_mahalanobis_summary.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="jitter", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_mahalanobis_common_support.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="qq", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_mahalanobis_qq.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="ecdf", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_mahalanobis_ecdf.png",
  width = 800,
  height = 1000
)

save_og_image(
  plot = plot(m.nearest_glm, type="density", which.xs = ~baseline_VA_logMAR + CCI + DCSI),
  filename = "images/m.nearest_mahalanobis_density.png",
  width = 800,
  height = 1000
)

```

#### Diagnostics

Overall, things look very similar with Mahalanobis matching.

##### Balance

![Post-matching (K:1 using Mahalanobis Distance) Imbalance](images/m.nearest_mahalanobis_summary.png)

Accounting:

* 25 measures
* 25 under 0.1 ASMD
* 24 under 0.05 ASMD

The numbers move around a bit, but this is basically identical.

##### Common Support/Equipoise

![Post-matching (K:1 using Logit) Common Support](images/m.nearest_mahalanobis_common_support.png)

We see all treatment are matched, and there is good common support. This implies that for each lapsed patient, there are similar people who did not lapse.



### ATT with weighting of non-comparable groups using Machine Learning


```{r twang, cache=shouldCache}
m.twang <- ps(
  formula = matchingFormula,
  data = data.frame(m_data),
  n.trees = 10000,
  interaction.depth = 3,
  estimand = "ATT"
)
summary(m.twang)
```

Note that the weighting procedure still drops about 1/4 of control cases (but no treatment). These are cases that differ substantially from treatment cases. (We may want to explore who exactly these cases are.)

```{r_twang_summary}

m.twang.balance <- bal.table(m.twang)
m.twang.balance

```

```{r twang_plots,echo=FALSE}
plot(m.twang, plots=3, main="Balance post-weighting")
plot(m.twang, plots=2, main="Common support")
plot(m.twang, plots=4, main="QQplot (on 45deg line = better)")
plot(m.twang, plots=5, main="Rank of p-value (above 45deg = better)")
```

This performs well; better than other matching techniques (as is my experience).

Note that here we get a logMAR reduction to 0.01 rather than 0.05 with the above techniques. The largest post-matching imbalance is on PRP (~0.05).

# Analysis

Lets run a simple model with each approach.

## Twang

```{r analysis_setup, echo=FALSE}
analysisFormulaSimple <- formula(
  outcome_va_vi_binary ~
    ever_lapse_binary
)

analysisFormulaMiddle <- formula(
  outcome_va_vi_binary ~
    ever_lapse_binary + 
    gender_cat +
    race_ethnic_cat +
    insurance_cat +
    age_cat +
    CCI +
    DCSI
)

analysisFormulaFull <- formula(
  outcome_va_vi_binary ~
    ever_lapse_binary + 
    gender_cat +
    race_ethnic_cat +
    insurance_cat +
    age_cat +
    CCI +
    DCSI +
    other_inject +
    anti_VEGF +
    focal_laser_flag +
    PRP_flag +
    glaucoma_bef_hitplus_cat +
    otherretina_bef_hitplus_cat +
    catsurg_before_hitplus_cat
)
```
  
#### Analysis 

Before starting, to prime our instincts, lets look at the `naive` model -- no matching, just clustering around patient ID.

```{r naive}
m.naive_design <- svydesign(ids=~e_mrn_deidentified, data=m_data)

m.naive_m1 <- svyglm(formula = analysisFormulaSimple, design=m.naive_design, family=binomial())
summary(m.naive_m1)

m_naive.m2 <- svyglm(formula = analysisFormulaMiddle, design=m.naive_design, data=m_data, family=quasibinomial())
summary(m_naive.m2)

m_naive.m3 <- svyglm(formula = analysisFormulaFull, design=m.naive_design, data=m_data, family=quasibinomial())
summary(m_naive.m3)
```

We estimate, in the full model, a `exp(0.4063)=1.50` odds ratio.

```{r analysis_twang}

m_data$twang_att_w <- get.weights(m.twang, stop.method="es.mean")
m.twang_design <- svydesign(ids=~e_mrn_deidentified, weights=~twang_att_w, data=m_data)

m_twang.m1 <- svyglm(formula = analysisFormulaSimple, design=m.twang_design, data=m_data, family=quasibinomial())
summary(m_twang.m1)

m_twang.m2 <- svyglm(formula = analysisFormulaMiddle, design=m.twang_design, data=m_data, family=quasibinomial())
summary(m_twang.m2)

m_twang.m3 <- svyglm(formula = analysisFormulaFull, design=m.twang_design, data=m_data, family=quasibinomial())
summary(m_twang.m3)
````

The coefficient of 0.17 is statistically significant across all models and stable.

Interpretation: the odds of those lapsing of developing vision loss vs not developing vision are 1.19 (`exp(0.1705) = 1.19`) times higher than the same odds of those who do not lapse.

#### Matching Model: K:1 with replacement using GLM matching

```{r analysis_matchit_glm}
m.nearest_glm_data <- match.data(m.nearest_glm)
m.nearest_glm_design <- svydesign(ids=~e_mrn_deidentified, data=m.nearest_glm_data)

m.nearest_glm.m1 <- svyglm(formula = analysisFormulaSimple, design=m.nearest_glm_design, family=binomial())
summary(m.nearest_glm.m1)

m.nearest_glm.m2 <- svyglm(formula = analysisFormulaMiddle, design=m.nearest_glm_design, family=binomial())
summary(m.nearest_glm.m2)

m.nearest_glm.m3 <- svyglm(formula = analysisFormulaFull, design=m.nearest_glm_design, family=binomial())
summary(m.nearest_glm.m3)
```

In the simplest model, we get a higher odds ratio.  However, as we build out the full model it reduces down to `exp(0.2156) = 1.24`, which is similar in substance to above.


#### Matching Model: K:1 with replacement using Mahalanobis matching

```{r analysis_matchit_glm}
m.nearest_mahalanobis_data <- match.data(m.nearest_mahalanobis)
m.nearest_mahalanobis_design <- svydesign(ids=~e_mrn_deidentified, data=m.nearest_mahalanobis_data)

m.nearest_mahalanobis.m1 <- svyglm(formula = analysisFormulaSimple, design=m.nearest_mahalanobis_design, family=binomial())
summary(m.nearest_mahalanobis.m1)

m.nearest_mahalanobis.m2 <- svyglm(formula = analysisFormulaMiddle, design=m.nearest_mahalanobis_design, family=binomial())
summary(m.nearest_mahalanobis.m2)

m.nearest_mahalanobis.m3 <- svyglm(formula = analysisFormulaFull, design=m.nearest_mahalanobis_design, family=binomial())
summary(m.nearest_mahalanobis.m3)
```

Here, something strange happens -- those who lapsed have an inverse relationship.  This should be explored.

