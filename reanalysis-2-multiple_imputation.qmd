---
title: "Reanalysis Step 2: Multiple Imputation"
subtitle: "Imputing missing values using mice package"
author: "Erik Westlund"
date: "`r Sys.Date()`"
format: html
---

## Setup

```{r setup}
#| include: false
source("dependencies.R")
source("functions.R")  # Load formula definitions and helper functions
seed <- 2025
setup_analysis(seed = seed)

# Additional packages for imputation
library(mice)
library(VIM)
library(naniar)

# Initialize logging
log_file <- init_log("multiple_imputation")

# ANALYSIS MODE: "test" or "final"
# test = 2 imputations, 2 iterations (fast)
# final = 50 imputations, 20 iterations (slow but thorough)
analysis_mode <- "test"  # Change to "final" for production run
log_message(paste0("Analysis mode: ", analysis_mode))

# Set parameters based on mode
if (analysis_mode == "test") {
  n_imputations <- 2
  n_iterations <- 2
} else if (analysis_mode == "final") {
  n_imputations <- 50
  n_iterations <- 20
} else {
  stop("Invalid analysis_mode. Must be 'test' or 'final'")
}

log_message(paste0("Imputations: ", n_imputations, ", Iterations: ", n_iterations))
```

**Running in `r toupper(analysis_mode)` mode:**  
- **Imputations:** `r n_imputations`  
- **Iterations:** `r n_iterations`

## Load Prepared Data

```{r load-data}
# Load the prepared dataset from Step 1
df_for_imputation <- readRDS(file.path(reanalysis_data_dir, "df_for_imputation.rds"))
variable_lists <- readRDS(file.path(reanalysis_data_dir, "variable_lists.rds"))

ps_model_vars <- variable_lists$ps_model_vars
outcome_model_vars <- variable_lists$outcome_model_vars

log_message(paste0("Loaded ", nrow(df_for_imputation), " observations"))
log_message(paste0("Unique patients: ", n_distinct(df_for_imputation$e_mrn_deidentified)))
```

## Create Fellow Eye Variables

```{r create-fellow-eye-vars}
# Create fellow eye variables by pairing eyes within patients
# This leverages correlation between eyes to improve imputation

# First, check data structure and create pairing
df_with_fellow <- df_for_imputation |>
  group_by(e_mrn_deidentified) |>
  mutate(
    n_eyes = n(),
    eye_index = row_number(),
    
    # Verify no patient has >2 eyes
    max_eyes_check = max(n_eyes)
  ) |>
  ungroup()

# Data check: Ensure no patient has >2 eyes
if (max(df_with_fellow$max_eyes_check) > 2) {
  stop("Found patients with >2 eyes. Check data quality.")
}
log_message(paste0("Maximum eyes per patient: ", max(df_with_fellow$max_eyes_check)))

# Create fellow variables
df_with_fellow <- df_with_fellow |>
  group_by(e_mrn_deidentified) |>
  mutate(
    # Fellow eye values (NA for single-eye patients)
    # Use [3 - eye_index] trick: eye 1 gets eye 2, eye 2 gets eye 1
    fellow_baseline_VA = if_else(n_eyes == 2, 
                                 baseline_VA_logMAR[3 - eye_index], 
                                 NA_real_),
    fellow_intermediate_VA = if_else(n_eyes == 2,
                                    intermediate_VA_logMAR[3 - eye_index],
                                    NA_real_),
    fellow_outcome_VA = if_else(n_eyes == 2,
                               outcome_VA_logMAR[3 - eye_index],
                               NA_real_)
    # Note: fellow_dr not needed since person_dr is already consistent within patients
  ) |>
  ungroup() |>
  select(-max_eyes_check, -eye_index)

# Patient distribution summary
patient_summary <- df_with_fellow |>
  group_by(e_mrn_deidentified) |>
  slice(1) |>  # One row per patient
  ungroup() |>
  summarise(
    total_patients = n(),
    single_eye_patients = sum(n_eyes == 1),
    bilateral_patients = sum(n_eyes == 2)
  )

log_message(paste0("Patient distribution - Total: ", patient_summary$total_patients,
                  ", Single eye: ", patient_summary$single_eye_patients,
                  ", Bilateral: ", patient_summary$bilateral_patients))

# Fellow data availability by cohort
fellow_check <- df_with_fellow |>
  filter(n_eyes == 2) |>
  group_by(cohort_id) |>
  summarise(
    n = n(),
    has_fellow_baseline = sum(!is.na(fellow_baseline_VA)),
    has_fellow_intermediate = sum(!is.na(fellow_intermediate_VA)),
    has_fellow_outcome = sum(!is.na(fellow_outcome_VA)),
    pct_fellow_baseline = round(100 * has_fellow_baseline / n, 1),
    pct_fellow_intermediate = round(100 * has_fellow_intermediate / n, 1),
    pct_fellow_outcome = round(100 * has_fellow_outcome / n, 1),
    .groups = 'drop'
  )

log_message("Fellow eye data availability by cohort:")
for(i in 1:nrow(fellow_check)) {
  log_message(paste0("  ", fellow_check$cohort_id[i], 
                    " - Baseline: ", fellow_check$pct_fellow_baseline[i], "%",
                    ", Intermediate: ", fellow_check$pct_fellow_intermediate[i], "%",
                    ", Outcome: ", fellow_check$pct_fellow_outcome[i], "%"))
}

# Eye correlation check (should be 0.5-0.9 typically)
correlation_check <- df_with_fellow |>
  filter(n_eyes == 2) |>
  summarise(
    cor_baseline = cor(baseline_VA_logMAR, fellow_baseline_VA, use = "complete.obs"),
    cor_intermediate = cor(intermediate_VA_logMAR, fellow_intermediate_VA, use = "complete.obs"),
    n_pairs_baseline = sum(!is.na(baseline_VA_logMAR) & !is.na(fellow_baseline_VA)),
    n_pairs_intermediate = sum(!is.na(intermediate_VA_logMAR) & !is.na(fellow_intermediate_VA))
  )

log_message(paste0("Fellow eye correlations - Baseline: ", round(correlation_check$cor_baseline, 3),
                  " (n=", correlation_check$n_pairs_baseline, " pairs)",
                  ", Intermediate: ", round(correlation_check$cor_intermediate, 3),
                  " (n=", correlation_check$n_pairs_intermediate, " pairs)"))

# Verification: Check fellow pairing worked correctly
pairing_check <- df_with_fellow |>
  filter(n_eyes == 2) |>
  group_by(e_mrn_deidentified) |>
  summarise(
    # Each eye should have the other eye's value as fellow
    check_baseline = baseline_VA_logMAR[1] == fellow_baseline_VA[2] & 
                    baseline_VA_logMAR[2] == fellow_baseline_VA[1],
    check_intermediate = (is.na(intermediate_VA_logMAR[1]) & is.na(fellow_intermediate_VA[2]) |
                         intermediate_VA_logMAR[1] == fellow_intermediate_VA[2]) &
                        (is.na(intermediate_VA_logMAR[2]) & is.na(fellow_intermediate_VA[1]) |
                         intermediate_VA_logMAR[2] == fellow_intermediate_VA[1]),
    .groups = 'drop'
  )

pairing_errors <- sum(!pairing_check$check_baseline | !pairing_check$check_intermediate, na.rm = TRUE)
if (pairing_errors > 0) {
  warning(paste0("Fellow eye pairing errors detected: ", pairing_errors, " patients"))
} else {
  log_message("Fellow eye pairing verification: PASSED")
}

# Use this enhanced dataset for imputation
df_for_imputation <- df_with_fellow
```

### Fellow Eye Data Summary

```{r fellow-summary-table}
# Display patient distribution
kable(patient_summary, caption = "Patient/Eye Distribution")

# Display fellow data availability
kable(fellow_check, 
      caption = "Fellow Eye Data Availability by Cohort (Bilateral Patients Only)",
      col.names = c("Cohort", "N Eyes", "Has Fellow Baseline", "Has Fellow Intermediate", 
                   "Has Fellow Outcome", "% Baseline", "% Intermediate", "% Outcome"))

# Display correlation summary
correlation_summary <- data.frame(
  Timepoint = c("Baseline", "Intermediate"),
  Correlation = c(correlation_check$cor_baseline, correlation_check$cor_intermediate),
  N_Pairs = c(correlation_check$n_pairs_baseline, correlation_check$n_pairs_intermediate)
)
kable(correlation_summary, 
      caption = "Inter-eye Correlations (Bilateral Patients)",
      digits = 3)
```

## Define Variables for Imputation

```{r define-imputation-vars}
# Variables to include in imputation model
# Include: outcome, exposure, all covariates source variables only
# Derived variables will be recreated post-imputation

# Core analysis variables - SOURCE ONLY
imputation_vars <- c(
  "e_mrn_deidentified",
  
  # Temporal VA variables
  "cohort_id",  # Data indicator only - not used as predictor
  "baseline_VA_logMAR",  # Baseline VA
  "intermediate_VA_logMAR",  # Intermediate follow-up VA (for excluded cohort)
  "outcome_VA_logMAR",  # 2-year outcome (true for submitted, missing for excluded)
  # NOT outcome_va_vi_binary - derived from logMAR >= 0.3
  
  # Exposure
  "ever_lapse_binary",
  
  # Demographics/Clinical
  "gender_cat",
  "race_ethnic_cat",
  "insurance_cat",
  "age",  # Continuous age (source)
  # NOT age_cat - derived from cut(age)
  "CCI",
  "DCSI",
  
  # Treatment indicators - ALL SOURCES
  "other_inject",
  "anti_VEGF",
  "focal_laser_flag",
  "PRP_flag",
  # NOT treatment_type or any_treatment - derived from these 4
  
  # Comorbidities (already recoded to 0/1)
  "glaucoma_bef_hitplus_cat",
  "otherretina_bef_hitplus_cat",
  "catsurg_before_hitplus_cat",
  
  # DR severity - use person_dr (created from No_DR/NPDR/PDR)
  "person_dr",  # Numeric 0/1/2
  # NOT dr_severity or person_dr_severity - derived from person_dr
  
  # Fellow eye variables (for bilateral patients)
  "fellow_baseline_VA",
  "fellow_intermediate_VA",
  "fellow_outcome_VA",
  "n_eyes"  # Number of eyes per patient (1 or 2)
)

# First, create person-level DR severity (maximum observed per patient)
df_person_dr <- df_for_imputation |>
  group_by(e_mrn_deidentified) |>
  summarise(
    # Take the maximum observed person_dr for each patient
    # This ensures consistency within patients
    person_dr_max = max(person_dr, na.rm = TRUE),
    # If all values are NA for a patient, max returns -Inf, so handle that
    person_dr_max = ifelse(is.infinite(person_dr_max), NA_real_, person_dr_max)
  ) |>
  ungroup()

df_mice <- df_for_imputation |>
  mutate(
    # Create a unique row identifier to preserve exact row matching
    row_id = row_number()
  ) |>
  # Join the person-level DR severity
  left_join(df_person_dr, by = "e_mrn_deidentified") |>
  dplyr::select(row_id, dplyr::all_of(imputation_vars), person_dr_max) |>
  mutate(
    # Convert person_dr_max to ordered factor for polr imputation method
    person_dr_max = factor(person_dr_max, levels = c(0, 1, 2), 
                          labels = c("No_DR", "NPDR", "PDR"),
                          ordered = TRUE),
    # Convert original person_dr to factor (keep for comparison but won't impute)
    person_dr = factor(person_dr, levels = c(0, 1, 2), 
                      labels = c("No_DR", "NPDR", "PDR"),
                      ordered = TRUE),
    # Lock factor levels for categorical variables to ensure consistency
    cohort_id = factor(cohort_id),  # Ensure cohort_id is a factor
    gender_cat = factor(gender_cat),
    race_ethnic_cat = factor(race_ethnic_cat),
    insurance_cat = factor(insurance_cat),
    
    # Convert binary variables to factors for logreg method
    # These need to be factors with 2 levels for mice logreg to work
    ever_lapse_binary = factor(ever_lapse_binary, levels = c(0, 1)),
    catsurg_before_hitplus_cat = factor(catsurg_before_hitplus_cat, levels = c(0, 1)),
    glaucoma_bef_hitplus_cat = factor(glaucoma_bef_hitplus_cat, levels = c(0, 1)),
    otherretina_bef_hitplus_cat = factor(otherretina_bef_hitplus_cat, levels = c(0, 1)),
    other_inject = factor(other_inject, levels = c(0, 1)),
    anti_VEGF = factor(anti_VEGF, levels = c(0, 1)),
    focal_laser_flag = factor(focal_laser_flag, levels = c(0, 1)),
    PRP_flag = factor(PRP_flag, levels = c(0, 1))
  )

log_message(paste0("Created person_dr_max: ", 
                  sum(!is.na(df_mice$person_dr_max)), " non-missing, ",
                  sum(is.na(df_mice$person_dr_max)), " missing"))
```

## Setup Imputation Model

```{r setup-mice}
# Initialize mice
# First, do a dry run to check the imputation setup
mice_dry <- mice(df_mice, maxit = 0, printFlag = FALSE)

# Imputation model summary
miss_vars <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  Pct_Missing = round(mice_dry$nmis/nrow(df_mice) * 100, 1)
) |>
  filter(N_Missing > 0) |>
  arrange(desc(N_Missing))
```

### Initial Imputation Model Summary

**Total variables in dataset:** `r ncol(df_mice)`  
**Variables to be imputed:** `r sum(mice_dry$nmis > 0)`  
**Total missing values:** `r sum(mice_dry$nmis)`  

**Missing data by variable:**
```{r missing-vars-table}
kable(miss_vars)

method_table <- data.frame(
  Variable = names(mice_dry$method),
  Method = mice_dry$method,
  stringsAsFactors = FALSE
) |>
  filter(Method != "")
```

**Initial imputation methods by variable:**
```{r method-table}
kable(method_table)

# Customize imputation methods as needed
custom_methods <- mice_dry$method

# Temporal VA variables
custom_methods["baseline_VA_logMAR"] <- "pmm"  # Impute if missing
custom_methods["intermediate_VA_logMAR"] <- "pmm"  # IMPUTE intermediate values
custom_methods["outcome_VA_logMAR"] <- "pmm"  # Impute 2-year outcomes
custom_methods["cohort_id"] <- ""  # Never impute - data management indicator only

# Other continuous variables
custom_methods["CCI"] <- "pmm"  # Predictive mean matching for count data
custom_methods["DCSI"] <- "pmm"  # Predictive mean matching for count data
custom_methods["age"] <- "pmm"

# Use proportional odds model for ordinal person_dr_max (0/1/2)
# person_dr_max is the person-level DR severity (consistent within patients)
custom_methods["person_dr_max"] <- "polr"  # Ordinal logistic regression
# Don't impute the original eye-level person_dr - it's replaced by person_dr_max
custom_methods["person_dr"] <- ""  # Don't impute eye-level DR

# Use logistic regression for binary variables
custom_methods["catsurg_before_hitplus_cat"] <- "logreg"

# Use polytomous regression for categorical variables with >2 levels
custom_methods["race_ethnic_cat"] <- "polyreg"
custom_methods["insurance_cat"] <- "polyreg"

# Don't impute these variables
# Method = "" means: don't impute (but still use as predictor EXCEPT for IDs)
custom_methods["row_id"] <- ""  # Row ID - never impute, never use as predictor; see below.
custom_methods["e_mrn_deidentified"] <- ""  # Patient ID - never impute, never use as predictor; see below.

# Fellow eye variables - don't impute (they're derived from existing data)
custom_methods["fellow_baseline_VA"] <- ""
custom_methods["fellow_intermediate_VA"] <- ""
custom_methods["fellow_outcome_VA"] <- ""
custom_methods["n_eyes"] <- ""  # Complete variable

# Variables that are complete (no missing data) - leave method empty
# mice will automatically skip variables with no missing data
# Only set methods for variables that actually have missing data to avoid type mismatches

# Note: Variables with complete data won't be imputed even if they have a method assigned
# The method specification ensures proper measurement level if imputation were needed

# Check predictor matrix (which variables predict which)
pred_matrix <- mice_dry$predictorMatrix

# Don't use IDs as predictors AND don't impute them
pred_matrix[, "e_mrn_deidentified"] <- 0
pred_matrix["e_mrn_deidentified", ] <- 0
pred_matrix[, "row_id"] <- 0
pred_matrix["row_id", ] <- 0

# TEMPORAL STRUCTURE RULES
# 1. Baseline can predict intermediate and outcome
pred_matrix["intermediate_VA_logMAR", "baseline_VA_logMAR"] <- 1
pred_matrix["outcome_VA_logMAR", "baseline_VA_logMAR"] <- 1

# 2. Intermediate can predict outcome
pred_matrix["outcome_VA_logMAR", "intermediate_VA_logMAR"] <- 1

# 3. CRITICAL: Prevent reverse-time prediction
pred_matrix["intermediate_VA_logMAR", "outcome_VA_logMAR"] <- 0  # Outcome cannot predict intermediate
pred_matrix["baseline_VA_logMAR", "outcome_VA_logMAR"] <- 0  # Outcome cannot predict baseline
pred_matrix["baseline_VA_logMAR", "intermediate_VA_logMAR"] <- 0  # Intermediate cannot predict baseline

# Cohort_id should not be predicted by anything AND should not predict anything
pred_matrix["cohort_id", ] <- 0  # Not predicted
pred_matrix[, "cohort_id"] <- 0  # Not a predictor

# Don't use variables as their own predictors
diag(pred_matrix) <- 0

# Ensure exposure is used as predictor for outcomes
pred_matrix[, "ever_lapse_binary"] <- 1
pred_matrix["ever_lapse_binary", "ever_lapse_binary"] <- 0

# Handle person_dr and person_dr_max
# person_dr (eye-level) should not be used as predictor or predicted
pred_matrix["person_dr", ] <- 0  # Not predicted
pred_matrix[, "person_dr"] <- 0  # Not a predictor

# person_dr_max (person-level) should be used as predictor but only for appropriate variables
# It can predict outcomes but not baseline variables
pred_matrix[, "person_dr_max"] <- 1  # Use as predictor for most variables
pred_matrix["person_dr_max", "person_dr_max"] <- 0  # Not its own predictor
pred_matrix["baseline_VA_logMAR", "person_dr_max"] <- 0  # Don't use to predict baseline VA
pred_matrix["row_id", "person_dr_max"] <- 0  # Don't use for IDs
pred_matrix["e_mrn_deidentified", "person_dr_max"] <- 0  # Don't use for IDs
pred_matrix["cohort_id", "person_dr_max"] <- 0  # Don't use for cohort_id

# FELLOW EYE PREDICTORS WITH TEMPORAL CONSTRAINTS
# Fellow baseline can predict all timepoints
if ("fellow_baseline_VA" %in% colnames(pred_matrix)) {
  pred_matrix["baseline_VA_logMAR", "fellow_baseline_VA"] <- 1
  pred_matrix["intermediate_VA_logMAR", "fellow_baseline_VA"] <- 1
  pred_matrix["outcome_VA_logMAR", "fellow_baseline_VA"] <- 1
}

# Fellow intermediate can predict intermediate and outcome (NOT baseline)
if ("fellow_intermediate_VA" %in% colnames(pred_matrix)) {
  pred_matrix["intermediate_VA_logMAR", "fellow_intermediate_VA"] <- 1
  pred_matrix["outcome_VA_logMAR", "fellow_intermediate_VA"] <- 1
  # CRITICAL: Prevent reverse-time prediction
  pred_matrix["baseline_VA_logMAR", "fellow_intermediate_VA"] <- 0
}

# Fellow outcome can predict outcome only (NOT earlier timepoints)
if ("fellow_outcome_VA" %in% colnames(pred_matrix)) {
  pred_matrix["outcome_VA_logMAR", "fellow_outcome_VA"] <- 1
  # CRITICAL: Prevent reverse-time prediction
  pred_matrix["baseline_VA_logMAR", "fellow_outcome_VA"] <- 0
  pred_matrix["intermediate_VA_logMAR", "fellow_outcome_VA"] <- 0
}

# Fellow variables are NEVER predicted (they're derived, not imputed)
fellow_vars <- c("fellow_baseline_VA", "fellow_intermediate_VA", "fellow_outcome_VA")
for (fvar in fellow_vars) {
  if (fvar %in% rownames(pred_matrix)) {
    pred_matrix[fvar, ] <- 0  # Not predicted by anything
  }
}

# n_eyes should not be used as predictor OR predicted
# It's perfectly correlated with fellow variable missingness patterns
if ("n_eyes" %in% rownames(pred_matrix)) {
  pred_matrix["n_eyes", ] <- 0  # Not predicted
  pred_matrix[, "n_eyes"] <- 0  # Not a predictor (causes collinearity)
}

# Log fellow predictor configuration
fellow_predictors_count <- c(
  baseline = sum(pred_matrix["baseline_VA_logMAR", grep("fellow", colnames(pred_matrix))]),
  intermediate = sum(pred_matrix["intermediate_VA_logMAR", grep("fellow", colnames(pred_matrix))]),
  outcome = sum(pred_matrix["outcome_VA_logMAR", grep("fellow", colnames(pred_matrix))])
)
log_message(paste0("Fellow predictors configured - Baseline: ", fellow_predictors_count["baseline"],
                  ", Intermediate: ", fellow_predictors_count["intermediate"],
                  ", Outcome: ", fellow_predictors_count["outcome"]))

# Save the predictor matrix to CSV for inspection
pred_matrix_df <- as.data.frame(pred_matrix)
pred_matrix_df <- cbind(Variable = rownames(pred_matrix_df), pred_matrix_df)
write.csv(pred_matrix_df, file.path(reanalysis_data_dir, "predictor_matrix.csv"), row.names = FALSE)
log_message(paste0("Saved predictor matrix to: ", file.path(reanalysis_data_dir, "predictor_matrix.csv")))

```

### Final Imputation Model Configuration

```{r final-model-config}

# Get actual missing data information
missing_info <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  stringsAsFactors = FALSE
)

# Summary of methods
final_methods <- data.frame(
  Variable = names(custom_methods),
  Method = custom_methods,
  Type = dplyr::case_when(
    custom_methods == "" ~ "Excluded (IDs - not used as predictor)",
    custom_methods == "pmm" ~ "Predictive mean matching",
    custom_methods == "polr" ~ "Proportional odds regression",
    custom_methods == "logreg" ~ "Logistic regression",
    custom_methods == "polyreg" ~ "Polytomous regression",
    TRUE ~ custom_methods
  ),
  stringsAsFactors = FALSE
) |>
  left_join(missing_info, by = "Variable") |>
  mutate(
    Will_Be_Imputed = N_Missing > 0 & Method != "",
    Role = case_when(
      Variable %in% c("row_id", "e_mrn_deidentified") ~ "ID (excluded)",
      N_Missing == 0 & Method != "" ~ "Complete predictor",
      N_Missing > 0 & Method != "" ~ "To be imputed",
      TRUE ~ "Other"
    )
  )

# Sort to show meaningful groupings
final_methods <- final_methods |>
  dplyr::arrange(Role == "ID (excluded)", N_Missing == 0, Variable)

# Variables that will ACTUALLY be imputed (have missing data AND a method)
# Exclude fellow variables and n_eyes even if they have missing data
vars_to_impute <- final_methods |>
  filter(Will_Be_Imputed) |>
  filter(!Variable %in% c("fellow_baseline_VA", "fellow_intermediate_VA", 
                          "fellow_outcome_VA", "n_eyes")) |>
  pull(Variable)
```

**Imputation methods and missing data by variable:**
```{r final-methods-table}
final_methods |>
  select(Variable, Type, N_Missing, Role) |>
  kable(col.names = c("Variable", "Method Type", "Missing Values", "Role in Imputation"))
```

**Variables that will ACTUALLY be imputed** (have missing data, `r length(vars_to_impute)` total):
```{r vars-to-impute}
if (length(vars_to_impute) > 0) {
  data.frame(
    Variable = vars_to_impute,
    Missing_Count = final_methods |> 
      filter(Variable %in% vars_to_impute) |> 
      pull(N_Missing)
  ) |>
  kable()
} else {
  no_imputation_msg <- "No variables require imputation (all data complete)"
  print(no_imputation_msg)
}

# Show complete variables with methods assigned
complete_with_methods <- final_methods |>
  filter(N_Missing == 0 & Method != "") |>
  select(Variable, Type)
```

**Complete variables with imputation methods assigned** (`r nrow(complete_with_methods)` total):
These variables have no missing data and won't be imputed, but have methods specified to ensure proper measurement level:
```{r complete-vars-table}
if (nrow(complete_with_methods) > 0) {
  kable(complete_with_methods, col.names = c("Variable", "Method Type"))
} else {
  no_complete_msg <- "No complete variables with methods assigned"
  print(no_complete_msg)
}

# Show predictor matrix summary
# Get the number of predictors for each variable
predictors_per_var <- rowSums(pred_matrix)

# Separate by variable type
id_vars_pred <- predictors_per_var[c("row_id", "e_mrn_deidentified")]
imputed_vars_pred <- predictors_per_var[vars_to_impute]
other_vars_pred <- predictors_per_var[!names(predictors_per_var) %in% c("row_id", "e_mrn_deidentified", vars_to_impute)]

# Calculate meaningful statistics
n_predictors_for_imputed <- if(length(imputed_vars_pred) > 0) unique(imputed_vars_pred)[1] else NA
predictors <- names(which(colSums(pred_matrix) > 0))

# Verify IDs are excluded
ids_excluded <- all(pred_matrix[, "row_id"] == 0) & all(pred_matrix[, "e_mrn_deidentified"] == 0)
```

### Predictor Matrix Summary

**Number of predictors used:**
- For variables being imputed: **`r if(!is.na(n_predictors_for_imputed)) n_predictors_for_imputed else 0`** predictors each
- For ID variables: **0** predictors (excluded from imputation)

**ID variables properly excluded from predictors:** `r if(ids_excluded) "Yes" else "No"`

**Variables used as predictors** (`r length(predictors)` total):
```{r predictor-list}
if ("row_id" %in% predictors || "e_mrn_deidentified" %in% predictors) {
  warning("WARNING: ID variables are being used as predictors! This should not happen.")
}
print(predictors)
```

### Visit Sequence

```{r visit-sequence}
# Define the order of imputation to respect temporal flow
# Impute earlier timepoints before later ones
visit_sequence <- c()

# First impute baseline if needed
if ("baseline_VA_logMAR" %in% vars_to_impute) {
  visit_sequence <- c(visit_sequence, "baseline_VA_logMAR")
}

# Then impute intermediate
if ("intermediate_VA_logMAR" %in% vars_to_impute) {
  visit_sequence <- c(visit_sequence, "intermediate_VA_logMAR")
}

# Then impute outcome
if ("outcome_VA_logMAR" %in% vars_to_impute) {
  visit_sequence <- c(visit_sequence, "outcome_VA_logMAR")
}

# Add other variables that need imputation
other_vars_to_impute <- vars_to_impute[!vars_to_impute %in% 
                                       c("baseline_VA_logMAR", 
                                         "intermediate_VA_logMAR", 
                                         "outcome_VA_logMAR")]
visit_sequence <- c(visit_sequence, other_vars_to_impute)

# Store for display
imputation_order <- paste(visit_sequence, collapse = ", ")
```

**Imputation order (respecting temporal structure):** `r imputation_order`

### Imputation Parameters

```{r imputation-params}
imp_params <- data.frame(
  Parameter = c("Mode", "Number of imputations (m)", "Max iterations (maxit)", "Random seed", "Visit sequence"),
  Value = c(analysis_mode, n_imputations, n_iterations, seed, "Temporal order enforced")
)
kable(imp_params)
```

## Run Multiple Imputation

```{r run-imputation}
# Run mice imputation
# Note: Parameters are set based on analysis_mode in setup
time_estimate <- if(analysis_mode == "test") "a few minutes" else "15-30 minutes or more"
```

**Starting multiple imputation...**

- Mode: `r analysis_mode`
- Imputations: `r n_imputations`
- Iterations: `r n_iterations`
- Estimated time: `r time_estimate`

```{r mice-run}
log_message("Starting MICE imputation...")
imp_start <- Sys.time()

mice_results <- mice(
  df_mice,
  m = n_imputations,
  method = custom_methods,
  predictorMatrix = pred_matrix,
  visitSequence = visit_sequence,  # Enforce temporal order
  maxit = n_iterations,  # Uses n_iterations from setup
  seed = 2025,
  printFlag = TRUE
)

imp_time <- round(as.numeric(difftime(Sys.time(), imp_start, units = "mins")), 2)
log_message(paste0("MICE imputation completed in ", imp_time, " minutes"))

# Log person_dr_max imputation status
if ("person_dr_max" %in% names(mice_results$imp)) {
  n_imputed_dr <- sum(mice_results$nmis["person_dr_max"])
  log_message(paste0("person_dr_max imputed for ", n_imputed_dr, " observations"))
}

# Check convergence
plot(mice_results)
```

## Create Complete Datasets and Derive Variables

```{r complete-datasets}
# Extract all imputed datasets
imputed_datasets <- complete(mice_results, action = "all")

# Apply transformation functions to recreate derived variables

imputed_datasets <- lapply(1:n_imputations, function(i) {
  imp_data <- imputed_datasets[[i]]
  
  # Apply transformation functions to recreate all derived variables
  imp_data <- imp_data |>
    create_outcome_variables() |>  # Creates outcome_va_vi_binary from logMAR
    create_age_cat() |>  # Creates age_cat from continuous age  
    create_treatment_type() |>  # Creates treatment_type and any_treatment
    create_dr_severity_variables()  # Creates dr_severity factor from person_dr
  
  return(imp_data)
})

# Add back any variables not included in imputation or transformation
# Get the full original dataset with row IDs
df_original_full <- df_for_imputation |>
  mutate(row_id = row_number())

# Variables to add back (those not in imputation model or created by transformations)
vars_in_imputed <- names(imputed_datasets[[1]])
# Remove row_id from comparison since it's our join key
vars_to_add <- setdiff(names(df_original_full), c(vars_in_imputed, "row_id"))
```

### Adding Back Non-Imputed Variables

**Variables to add back:** `r if(length(vars_to_add) > 0) length(vars_to_add) else 0` variables not in imputation model

```{r add-back-vars}
if(length(vars_to_add) > 0) {
  # IMPORTANT: Exclude No_DR, NPDR, PDR from vars_to_add to prevent overwriting person_dr
  # These would cause create_dr_severity_variables to recalculate person_dr from eye-level data
  original_vars_to_add <- vars_to_add
  vars_to_add <- setdiff(vars_to_add, c("No_DR", "NPDR", "PDR"))
  
  if (length(original_vars_to_add) != length(vars_to_add)) {
    log_message("Excluded No_DR/NPDR/PDR from variables to add back to preserve person_dr consistency")
  }
  
  # Add these variables back to each imputed dataset using row_id for exact matching
  imputed_datasets <- lapply(imputed_datasets, function(imp_data) {
    # Store original row count
    orig_rows <- nrow(imp_data)
    
    # Store the consistent person_dr we just created
    person_dr_consistent <- imp_data$person_dr
    
    # Join using row_id for exact 1:1 matching
    imp_data <- imp_data |>
      left_join(
        df_original_full |> 
          dplyr::select(row_id, dplyr::all_of(vars_to_add)),
        by = "row_id"
      ) |>
      # Ensure person_dr remains consistent (in case it somehow got overwritten)
      mutate(person_dr = person_dr_consistent)
    
    # Verify no row duplication
    if (nrow(imp_data) != orig_rows) {
      stop("Join changed row count from ", orig_rows, " to ", nrow(imp_data), 
           ". This should not happen with row_id join.")
    }
    
    # Remove row_id as it's no longer needed
    imp_data <- imp_data |> select(-row_id)
    
    return(imp_data)
  })
}

# FINAL STEP: Enforce patient-level variable consistency across all datasets
# person_dr, CCI, and DCSI should be consistent within patients
imputed_datasets <- lapply(imputed_datasets, function(imp_data) {
  # Calculate consistent values per patient (using max for all)
  patient_level_vars <- imp_data |>
    group_by(e_mrn_deidentified) |>
    summarise(
      # Handle case where all values are NA (max returns -Inf)
      person_dr_consistent = ifelse(all(is.na(person_dr)), 
                                   NA_real_, 
                                   max(person_dr, na.rm = TRUE)),
      CCI_consistent = ifelse(all(is.na(CCI)), 
                             NA_real_, 
                             max(CCI, na.rm = TRUE)),
      DCSI_consistent = ifelse(all(is.na(DCSI)), 
                              NA_real_, 
                              max(DCSI, na.rm = TRUE)),
      .groups = 'drop'
    )
  
  # Replace with consistent values
  imp_data <- imp_data |>
    left_join(patient_level_vars, by = "e_mrn_deidentified") |>
    mutate(
      person_dr = person_dr_consistent,
      CCI = CCI_consistent,
      DCSI = DCSI_consistent
    ) |>
    select(-person_dr_consistent, -CCI_consistent, -DCSI_consistent)
  
  return(imp_data)
})

log_message("Enforced patient-level consistency for person_dr, CCI, and DCSI by taking max value per patient")

completeness_check <- lapply(imputed_datasets, function(d) {
  sum(!complete.cases(d[, ps_model_vars]))
})

```

### Completeness Check

**Number of incomplete cases in PS model variables per imputed dataset:**
```{r completeness-results}
print(unlist(completeness_check))
```

### Patient-Level Variable Consistency Check

```{r patient-consistency-check}
# Check that patient-level variables are consistent within patients after imputation
consistency_check <- lapply(1:n_imputations, function(i) {
  imp_data <- imputed_datasets[[i]]
  
  # Check consistency of person_dr, CCI, and DCSI within patients
  patient_check <- imp_data |>
    group_by(e_mrn_deidentified) |>
    summarise(
      n_eyes = n(),
      unique_dr = n_distinct(person_dr, na.rm = TRUE),
      unique_cci = n_distinct(CCI, na.rm = TRUE),
      unique_dcsi = n_distinct(DCSI, na.rm = TRUE),
      dr_consistent = unique_dr <= 1,
      cci_consistent = unique_cci <= 1,
      dcsi_consistent = unique_dcsi <= 1,
      all_consistent = dr_consistent & cci_consistent & dcsi_consistent
    )
  
  return(list(
    dataset = i,
    n_patients = nrow(patient_check),
    dr_pct_consistent = round(mean(patient_check$dr_consistent) * 100, 2),
    cci_pct_consistent = round(mean(patient_check$cci_consistent) * 100, 2),
    dcsi_pct_consistent = round(mean(patient_check$dcsi_consistent) * 100, 2),
    all_pct_consistent = round(mean(patient_check$all_consistent) * 100, 2)
  ))
})

# Display results
consistency_df <- bind_rows(consistency_check)
log_message(paste0("Patient-level consistency - person_dr: ", 
                  min(consistency_df$dr_pct_consistent), "%, ",
                  "CCI: ", min(consistency_df$cci_pct_consistent), "%, ",
                  "DCSI: ", min(consistency_df$dcsi_pct_consistent), "%"))
```

**Patient-level variable consistency after imputation:**
```{r consistency-table}
kable(consistency_df, 
      col.names = c("Dataset", "Patients", "DR %", "CCI %", "DCSI %", "All %"),
      caption = "Percentage of patients with consistent values across eyes")
```

### Fellow Eye Correlation After Imputation

```{r fellow-correlation-check}
# Check that fellow eye correlations remain realistic after imputation
fellow_correlation_check <- lapply(1:n_imputations, function(i) {
  imp_data <- imputed_datasets[[i]]
  
  # Calculate correlations for bilateral patients
  cor_check <- imp_data |>
    filter(!is.na(n_eyes) & n_eyes == 2) |>
    summarise(
      cor_baseline = cor(baseline_VA_logMAR, fellow_baseline_VA, use = "complete.obs"),
      cor_intermediate = cor(intermediate_VA_logMAR, fellow_intermediate_VA, use = "complete.obs"),
      cor_outcome = cor(outcome_VA_logMAR, fellow_outcome_VA, use = "complete.obs"),
      n_baseline = sum(!is.na(baseline_VA_logMAR) & !is.na(fellow_baseline_VA)),
      n_intermediate = sum(!is.na(intermediate_VA_logMAR) & !is.na(fellow_intermediate_VA)),
      n_outcome = sum(!is.na(outcome_VA_logMAR) & !is.na(fellow_outcome_VA))
    )
  
  return(list(
    dataset = i,
    cor_baseline = round(cor_check$cor_baseline, 3),
    cor_intermediate = round(cor_check$cor_intermediate, 3),
    cor_outcome = round(cor_check$cor_outcome, 3),
    n_baseline = cor_check$n_baseline,
    n_intermediate = cor_check$n_intermediate,
    n_outcome = cor_check$n_outcome
  ))
})

# Display results
fellow_cor_df <- bind_rows(fellow_correlation_check)
log_message(paste0("Post-imputation fellow eye correlations - Outcome: ",
                  min(fellow_cor_df$cor_outcome, na.rm = TRUE), " to ",
                  max(fellow_cor_df$cor_outcome, na.rm = TRUE)))

# Check if correlations are in reasonable range (0.5-0.9 typically)
cor_warnings <- fellow_cor_df |>
  mutate(
    baseline_ok = cor_baseline >= 0.5 & cor_baseline <= 0.95,
    intermediate_ok = cor_intermediate >= 0.5 & cor_intermediate <= 0.95,
    outcome_ok = cor_outcome >= 0.5 & cor_outcome <= 0.95
  )

if (any(!cor_warnings$outcome_ok, na.rm = TRUE)) {
  warning("Some imputed datasets have fellow eye outcome correlations outside expected range (0.5-0.95)")
}
```

**Fellow eye correlations after imputation:**
```{r fellow-correlation-table}
kable(fellow_cor_df |> select(-starts_with("n_")), 
      col.names = c("Dataset", "Baseline", "Intermediate", "Outcome"),
      caption = "Inter-eye Correlations After Imputation (Bilateral Patients)",
      digits = 3)

# Also show the sample sizes
kable(fellow_cor_df |> select(dataset, starts_with("n_")), 
      col.names = c("Dataset", "N Baseline", "N Intermediate", "N Outcome"),
      caption = "Number of Paired Observations Used for Correlations")
```

## Save Imputed Datasets

```{r save-imputed}
saveRDS(mice_results, file.path(reanalysis_data_dir, "mice_results.rds"))
saveRDS(imputed_datasets, file.path(reanalysis_data_dir, "imputed_datasets.rds"))
saveRDS(imputed_datasets[[1]], file.path(reanalysis_data_dir, "imputed_dataset_1.rds"))
```

**Saved `r n_imputations` imputed datasets to:** `r reanalysis_data_dir`

```{r empty-chunk}
```

## Summary

```{r summary}
# Count variables more precisely
# Total columns in df_mice includes row_id which we added
total_vars <- ncol(df_mice)
id_vars <- 2  # row_id and e_mrn_deidentified
substantive_vars <- total_vars - id_vars  # Variables actually used in the imputation model

summary_table <- tibble(
  Metric = c(
    "Original observations",
    "Total variables in dataset",
    "ID variables (excluded from model)",
    "Substantive variables in imputation model",
    "Variables with missing data",
    "Variables actually imputed",
    "Number of imputations",
    "Maximum missing percentage",
    "Imputation iterations"
  ),
  Value = c(
    nrow(df_mice),
    total_vars,
    id_vars,
    substantive_vars,
    sum(mice_results$nmis > 0),
    length(vars_to_impute),
    n_imputations,
    paste0(round(max(mice_results$nmis/nrow(df_mice)) * 100, 1), "%"),
    mice_results$iteration
  )
)

summary_table |>
  kable(caption = "Multiple imputation summary")

imputed_vars <- names(mice_results$nmis)[mice_results$nmis > 0]
```

**Variables that were imputed:**
```{r imputed-vars-list}
print(imputed_vars)
```

### Temporal VA Imputation Summary

- **Baseline VA:** Starting point for temporal chain
- **Intermediate VA:** Bridge between baseline and 2-year outcome
  - For "submitted" cohort with observed outcome: set to outcome value
  - For "excluded" cohort: contains observed intermediate follow-up values
  - Reduces missing data substantially compared to leaving as NA
- **Outcome VA:** Final 2-year outcome (missing for 'excluded' cohort)
- **Temporal order enforced:** baseline → intermediate → outcome
- **No reverse-time prediction allowed**
