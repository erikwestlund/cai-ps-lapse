---
title: "Reanalysis Step 2: Multiple Imputation"
subtitle: "Imputing missing values using mice with strict temporal and fellow-eye constraints"
author: "Erik Westlund"
date: "`r Sys.Date()`"
format: html
---

::: {.callout-important}
## Key Change from Previous Version
`cohort_id` has been removed from the imputation model to avoid perfect prediction issues. The variable perfectly predicted outcome missingness (all 'excluded' had missing outcomes, all 'submitted' had observed outcomes), preventing successful imputation. The variable is preserved and added back after imputation for tracking purposes.
:::

## Setup

```{r setup}
#| include: false
source("dependencies.R")
source("functions.R")  # Load formula definitions and helper functions
seed <- 2025
setup_analysis(seed = seed)

# Packages
library(mice)
library(VIM)
library(naniar)
library(dplyr)
library(tidyr)
library(knitr)
library(tibble)

# ANALYSIS MODE: "test" or "final"
# test = 2 imputations, 3 iterations (fast)
# final = 30 imputations, 20 iterations (stability achieved ~20)
analysis_mode <- "test"

if (analysis_mode == "test") {
  n_imputations <- 2
  n_iterations <- 3
} else if (analysis_mode == "final") {
  n_imputations <- 30
  n_iterations <- 20
} else {
  stop("Invalid analysis_mode. Must be 'test' or 'final'")
}

# Initialize logging
log_file <- init_log("multiple_imputation")
log_message(paste0("Analysis mode: ", analysis_mode))
log_message(paste0("Imputations: ", n_imputations, ", Iterations: ", n_iterations))
```

## Load Prepared Data

```{r load-data}
# Load the prepared dataset from Step 1
df_for_imputation <- readRDS(file.path(reanalysis_data_dir, "df_for_imputation.rds"))
variable_lists <- readRDS(file.path(reanalysis_data_dir, "variable_lists.rds"))

ps_model_vars <- variable_lists$ps_model_vars
outcome_model_vars <- variable_lists$outcome_model_vars

# Quick record/patient counts
log_message(paste0("Loaded records: ", nrow(df_for_imputation)))
if ("e_mrn_deidentified" %in% names(df_for_imputation)) {
  log_message(paste0("Unique patients: ", dplyr::n_distinct(df_for_imputation$e_mrn_deidentified)))
}
```

## Define Variables for Imputation

```{r define-imputation-vars}
# Variables to include in imputation model (SOURCE variables only)
# Derived variables will be recreated post-imputation

imputation_vars <- c(
  "e_mrn_deidentified",
  
  # Temporal VA variables
  # NOTE: cohort_id REMOVED - it perfectly predicts outcome missingness
  "baseline_VA_logMAR",        # Baseline VA
  "intermediate_VA_logMAR",    # Intermediate follow-up VA
  "outcome_VA_logMAR",         # 2-year outcome
  # NOT outcome_va_vi_binary - derived from logMAR threshold
  
  # Exposure
  "ever_lapse_binary",
  
  # Demographics/Clinical
  "gender_cat",
  "race_ethnic_cat",
  "insurance_cat",
  "age",                        # Continuous age (source)
  # NOT age_cat - derived from cut(age)
  "CCI",
  "DCSI",
  
  # Treatment indicators - ALL SOURCES
  "other_inject",
  "anti_VEGF",
  "focal_laser_flag",
  "PRP_flag",
  # NOT treatment_type or any_treatment - derived from these 4
  
  # Comorbidities (already recoded to 0/1)
  "glaucoma_bef_hitplus_cat",
  "otherretina_bef_hitplus_cat",
  "catsurg_before_hitplus_cat",
  
  # DR severity - use person_dr (created from No_DR/NPDR/PDR)
  "person_dr"                  # Numeric 0/1/2 â†’ ordered factor
  # NOT dr_severity/person_dr_severity - derived from person_dr
)

df_mice <- df_for_imputation |>
  mutate(
    # Create a unique row identifier to preserve exact row matching
    row_id = dplyr::row_number(),
    # Store cohort_id separately for later use (not in imputation)
    cohort_id_original = cohort_id
  ) |>
  dplyr::select(row_id, cohort_id_original, dplyr::all_of(imputation_vars)) |>
  mutate(
    # Convert person_dr to ordered factor for polr imputation method
    person_dr = factor(person_dr, levels = c(0, 1, 2),
                       labels = c("No_DR", "NPDR", "PDR"),
                       ordered = TRUE),
    # Lock factor levels for categorical variables to ensure consistency
    gender_cat = factor(gender_cat),
    race_ethnic_cat = factor(race_ethnic_cat),
    insurance_cat = factor(insurance_cat)
  ) |>
  # Fellow-eye variables (computed within patient clusters)
  dplyr::group_by(e_mrn_deidentified) |>
  dplyr::mutate(
    n_eyes = dplyr::n(),
    eye_index = dplyr::row_number(),
    fellow_baseline_VA = dplyr::if_else(n_eyes == 2, baseline_VA_logMAR[3 - eye_index], as.numeric(NA)),
    fellow_intermediate_VA = dplyr::if_else(n_eyes == 2, intermediate_VA_logMAR[3 - eye_index], as.numeric(NA)),
    fellow_outcome_VA = dplyr::if_else(n_eyes == 2, outcome_VA_logMAR[3 - eye_index], as.numeric(NA)),
    fellow_dr = dplyr::if_else(n_eyes == 2,
                               person_dr[3 - eye_index],
                               factor(NA, levels = levels(person_dr), ordered = TRUE))
  ) |>
  dplyr::ungroup() |>
  dplyr::select(-eye_index)
```

## Setup Imputation Model (dry run and methods)

```{r setup-mice}
# Dry run to inspect missingness and defaults
mice_dry <- mice(df_mice, maxit = 0, printFlag = FALSE)

# Missingness summary
miss_vars <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  Pct_Missing = round(mice_dry$nmis/nrow(df_mice) * 100, 1)
) |>
  dplyr::filter(N_Missing > 0) |>
  dplyr::arrange(dplyr::desc(N_Missing))

log_message("Variables with missing data:")
print(miss_vars)

# Check that key variables are in the dataset
log_message("\nChecking for key variables in df_mice:")
key_vars_present <- c("baseline_VA_logMAR", "intermediate_VA_logMAR", "outcome_VA_logMAR", "person_dr")
for (v in key_vars_present) {
  if (v %in% names(df_mice)) {
    n_miss <- sum(is.na(df_mice[[v]]))
    log_message(paste0(v, ": Present (", n_miss, " missing)"))
  } else {
    log_message(paste0(v, ": NOT PRESENT IN DATA"))
  }
}

# Configure methods explicitly
custom_methods <- mice_dry$method

log_message("\nDefault methods from mice:")
print(custom_methods)

# Temporal VA variables
custom_methods["baseline_VA_logMAR"] <- "pmm"
custom_methods["intermediate_VA_logMAR"] <- "pmm"
custom_methods["outcome_VA_logMAR"] <- "pmm"
# cohort_id removed from dataset to avoid perfect prediction

# Other continuous
custom_methods["CCI"] <- "pmm"
custom_methods["DCSI"] <- "pmm"
custom_methods["age"] <- "pmm"

# Ordinal
custom_methods["person_dr"] <- "polr"

# Binary
custom_methods["catsurg_before_hitplus_cat"] <- "logreg"
custom_methods["ever_lapse_binary"] <- "logreg"  # likely complete, ok to set type
custom_methods["glaucoma_bef_hitplus_cat"] <- "logreg"
custom_methods["otherretina_bef_hitplus_cat"] <- "logreg"
custom_methods["gender_cat"] <- "logreg"  # if binary
custom_methods["other_inject"] <- "logreg"
custom_methods["anti_VEGF"] <- "logreg"
custom_methods["focal_laser_flag"] <- "logreg"
custom_methods["PRP_flag"] <- "logreg"

# Polytomous
custom_methods["race_ethnic_cat"] <- "polyreg"
custom_methods["insurance_cat"] <- "polyreg"

# IDs and fellow-eye variables: never impute
custom_methods["row_id"] <- ""
custom_methods["e_mrn_deidentified"] <- ""
custom_methods["cohort_id_original"] <- ""  # Stored for later, not imputed
for (fv in c("fellow_baseline_VA", "fellow_intermediate_VA", "fellow_outcome_VA", "fellow_dr", "n_eyes")) {
  if (fv %in% names(custom_methods)) custom_methods[fv] <- ""
}

# DIAGNOSTIC: Verify methods are set correctly
log_message("\nMethods for variables with missing data:")
for (v in miss_vars$Variable) {
  if (v %in% names(custom_methods)) {
    log_message(paste0(v, ": ", custom_methods[v]))
  } else {
    log_message(paste0(v, ": NOT IN METHODS VECTOR"))
  }
}

# DIAGNOSTIC: Check which variables will actually be imputed
vars_to_impute_check <- names(custom_methods)[custom_methods != "" & mice_dry$nmis > 0]
log_message(paste0("\nVariables that SHOULD be imputed (method != '' and has missing): ", 
                   length(vars_to_impute_check)))
print(vars_to_impute_check)
```

### Initial Imputation Model Summary

**Total variables in dataset:** `r ncol(df_mice)`  
**Variables to be imputed:** `r sum(mice_dry$nmis > 0)`  
**Total missing values:** `r sum(mice_dry$nmis)`

**Missing data by variable:**
```{r missing-vars-table}
kable(miss_vars)
```

## Setup Predictor Matrix (strict temporal + fellow-eye logic)

```{r setup-predictors}
# Start with empty matrix, then opt in predictors explicitly
pred_matrix <- matrix(0, nrow = ncol(df_mice), ncol = ncol(df_mice))
colnames(pred_matrix) <- names(df_mice)
rownames(pred_matrix) <- names(df_mice)

# Never impute IDs (row = 0) and never use them as predictors (col = 0)
for (idv in c("row_id", "e_mrn_deidentified", "cohort_id_original")) {
  if (idv %in% rownames(pred_matrix)) pred_matrix[idv, ] <- 0
  if (idv %in% colnames(pred_matrix)) pred_matrix[, idv] <- 0
}

# Never impute but can be used as predictors: ever_lapse_binary
if ("ever_lapse_binary" %in% rownames(pred_matrix)) pred_matrix["ever_lapse_binary", ] <- 0
# cohort_id removed entirely to avoid perfect prediction issues

# Fellow-eye and helper vars are predictors only (never imputed)
fellow_vars <- c("fellow_baseline_VA", "fellow_intermediate_VA", "fellow_outcome_VA", "fellow_dr", "n_eyes")
for (fv in fellow_vars) {
  if (fv %in% rownames(pred_matrix)) pred_matrix[fv, ] <- 0
}

# Variable groups
demographic_vars <- c("age", "gender_cat", "race_ethnic_cat", "insurance_cat")
global_comorbidity_vars <- c("CCI", "DCSI")
ocular_comorbidity_vars <- c("glaucoma_bef_hitplus_cat", "otherretina_bef_hitplus_cat", "catsurg_before_hitplus_cat")
treatment_vars <- c("anti_VEGF", "focal_laser_flag", "PRP_flag", "other_inject")

# baseline_VA_logMAR predictors (no future info)
if ("baseline_VA_logMAR" %in% rownames(pred_matrix)) {
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["baseline_VA_logMAR", v] <- 1
  for (v in global_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["baseline_VA_logMAR", v] <- 1
  for (v in ocular_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["baseline_VA_logMAR", v] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["baseline_VA_logMAR", "ever_lapse_binary"] <- 1
  if ("fellow_baseline_VA" %in% colnames(pred_matrix)) pred_matrix["baseline_VA_logMAR", "fellow_baseline_VA"] <- 1
}

# intermediate_VA_logMAR predictors (no treatments, no future)
if ("intermediate_VA_logMAR" %in% rownames(pred_matrix)) {
  if ("baseline_VA_logMAR" %in% colnames(pred_matrix)) pred_matrix["intermediate_VA_logMAR", "baseline_VA_logMAR"] <- 1
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["intermediate_VA_logMAR", v] <- 1
  for (v in global_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["intermediate_VA_logMAR", v] <- 1
  for (v in ocular_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["intermediate_VA_logMAR", v] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["intermediate_VA_logMAR", "ever_lapse_binary"] <- 1
  if ("fellow_baseline_VA" %in% colnames(pred_matrix)) pred_matrix["intermediate_VA_logMAR", "fellow_baseline_VA"] <- 1
  # Explicitly exclude future/fellow-intermediate via omission (remain 0)
}

# outcome_VA_logMAR predictors (allow treatments and fellow baseline/outcome)
if ("outcome_VA_logMAR" %in% rownames(pred_matrix)) {
  if ("baseline_VA_logMAR" %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", "baseline_VA_logMAR"] <- 1
  if ("intermediate_VA_logMAR" %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", "intermediate_VA_logMAR"] <- 1
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", v] <- 1
  for (v in global_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", v] <- 1
  for (v in ocular_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", v] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", "ever_lapse_binary"] <- 1
  for (v in treatment_vars) if (v %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", v] <- 1
  if ("fellow_baseline_VA" %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", "fellow_baseline_VA"] <- 1
  if ("fellow_outcome_VA" %in% colnames(pred_matrix)) pred_matrix["outcome_VA_logMAR", "fellow_outcome_VA"] <- 1
}

# person_dr predictors (pre-outcome only, include fellow_baseline_VA and fellow_dr)
if ("person_dr" %in% rownames(pred_matrix)) {
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["person_dr", v] <- 1
  for (v in global_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["person_dr", v] <- 1
  for (v in ocular_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["person_dr", v] <- 1
  if ("baseline_VA_logMAR" %in% colnames(pred_matrix)) pred_matrix["person_dr", "baseline_VA_logMAR"] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["person_dr", "ever_lapse_binary"] <- 1
  for (v in treatment_vars) if (v %in% colnames(pred_matrix)) pred_matrix["person_dr", v] <- 1
  if ("fellow_baseline_VA" %in% colnames(pred_matrix)) pred_matrix["person_dr", "fellow_baseline_VA"] <- 1
  if ("fellow_dr" %in% colnames(pred_matrix)) pred_matrix["person_dr", "fellow_dr"] <- 1
}

# Demographics predict each other
for (v1 in demographic_vars) for (v2 in demographic_vars) {
  if (!identical(v1, v2) && v1 %in% rownames(pred_matrix) && v2 %in% colnames(pred_matrix)) pred_matrix[v1, v2] <- 1
}

# CCI and DCSI predict each other and are predicted by demographics and exposure
if ("CCI" %in% rownames(pred_matrix)) {
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["CCI", v] <- 1
  if ("DCSI" %in% colnames(pred_matrix)) pred_matrix["CCI", "DCSI"] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["CCI", "ever_lapse_binary"] <- 1
}
if ("DCSI" %in% rownames(pred_matrix)) {
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["DCSI", v] <- 1
  if ("CCI" %in% colnames(pred_matrix)) pred_matrix["DCSI", "CCI"] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["DCSI", "ever_lapse_binary"] <- 1
}

# Cataract surgery predicted by demographics/comorbidities/exposure
if ("catsurg_before_hitplus_cat" %in% rownames(pred_matrix)) {
  for (v in demographic_vars) if (v %in% colnames(pred_matrix)) pred_matrix["catsurg_before_hitplus_cat", v] <- 1
  for (v in global_comorbidity_vars) if (v %in% colnames(pred_matrix)) pred_matrix["catsurg_before_hitplus_cat", v] <- 1
  if ("ever_lapse_binary" %in% colnames(pred_matrix)) pred_matrix["catsurg_before_hitplus_cat", "ever_lapse_binary"] <- 1
}

# Treatment variables predict each other
for (v1 in treatment_vars) for (v2 in treatment_vars) {
  if (!identical(v1, v2) && v1 %in% rownames(pred_matrix) && v2 %in% colnames(pred_matrix)) pred_matrix[v1, v2] <- 1
}

log_message("Predictor matrix configured with strict temporal and fellow-eye constraints")

# Save the predictor matrix to CSV for inspection
pred_matrix_df <- as.data.frame(pred_matrix)
pred_matrix_df <- cbind(Variable = rownames(pred_matrix_df), pred_matrix_df)
write.csv(pred_matrix_df, file.path(reanalysis_data_dir, "predictor_matrix.csv"), row.names = FALSE)
log_message(paste0("Saved predictor matrix to: ", file.path(reanalysis_data_dir, "predictor_matrix.csv")))

# Simple verification prints
pred_counts <- data.frame(
  Variable = rownames(pred_matrix),
  N_Predictors = rowSums(pred_matrix > 0),
  N_Times_Used_As_Predictor = colSums(pred_matrix > 0)[rownames(pred_matrix)]
)
pred_counts <- pred_counts[order(-pred_counts$N_Predictors), ]
print(pred_counts)

# Detailed predictors for key variables
for (var in c("baseline_VA_logMAR", "intermediate_VA_logMAR", "outcome_VA_logMAR", "person_dr")) {
  if (var %in% rownames(pred_matrix)) {
    predictors <- colnames(pred_matrix)[pred_matrix[var, ] == 1]
    log_message(paste0("Predictors for ", var, " (", length(predictors), "): ", paste(predictors, collapse = ", ")))
  }
}
```

### Final Imputation Model Configuration

```{r final-model-config}
missing_info <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  stringsAsFactors = FALSE
)

final_methods <- data.frame(
  Variable = names(custom_methods),
  Method = custom_methods,
  Type = dplyr::case_when(
    custom_methods == "" ~ "Excluded (not imputed)",
    custom_methods == "pmm" ~ "Predictive mean matching",
    custom_methods == "polr" ~ "Proportional odds regression",
    custom_methods == "logreg" ~ "Logistic regression",
    custom_methods == "polyreg" ~ "Polytomous regression",
    TRUE ~ custom_methods
  ),
  stringsAsFactors = FALSE
) |>
  dplyr::left_join(missing_info, by = "Variable") |>
  dplyr::mutate(
    Will_Be_Imputed = N_Missing > 0 & Method != "",
    Role = dplyr::case_when(
      Variable %in% c("row_id", "e_mrn_deidentified") ~ "ID (excluded)",
      Variable %in% fellow_vars ~ "Fellow (predictor only)",
      N_Missing == 0 & Method != "" ~ "Complete predictor",
      N_Missing > 0 & Method != "" ~ "To be imputed",
      TRUE ~ "Other"
    )
  )

vars_to_impute <- final_methods |>
  dplyr::filter(Will_Be_Imputed) |>
  dplyr::pull(Variable)

kable(final_methods |>
        dplyr::select(Variable, Type, N_Missing, Role) |>
        dplyr::arrange(Role == "ID (excluded)", Role == "Fellow (predictor only)", dplyr::desc(N_Missing)),
      col.names = c("Variable", "Method Type", "Missing Values", "Role in Imputation"))
```

### Visit Sequence

```{r visit-sequence}
visit_sequence <- c()
if ("baseline_VA_logMAR" %in% vars_to_impute) visit_sequence <- c(visit_sequence, "baseline_VA_logMAR")
if ("intermediate_VA_logMAR" %in% vars_to_impute) visit_sequence <- c(visit_sequence, "intermediate_VA_logMAR")
if ("outcome_VA_logMAR" %in% vars_to_impute) visit_sequence <- c(visit_sequence, "outcome_VA_logMAR")
other_vars_to_impute <- setdiff(vars_to_impute, c("baseline_VA_logMAR", "intermediate_VA_logMAR", "outcome_VA_logMAR"))
visit_sequence <- c(visit_sequence, other_vars_to_impute)
imputation_order <- paste(visit_sequence, collapse = ", ")
```

**Imputation order (respecting temporal structure):** `r imputation_order`

### Imputation Parameters

```{r imputation-params}
imp_params <- data.frame(
  Parameter = c("Mode", "Number of imputations (m)", "Max iterations (maxit)", "Random seed", "Visit sequence"),
  Value = c(analysis_mode, n_imputations, n_iterations, seed, ifelse(length(visit_sequence) > 0, "Temporal order enforced", "Default"))
)
kable(imp_params)
```

## Run Multiple Imputation

```{r mice-run}
log_message("Starting MICE imputation process...")

# DIAGNOSTIC: Final check before imputation
log_message("\nFinal pre-imputation checks:")
log_message(paste0("Number of rows in df_mice: ", nrow(df_mice)))
log_message(paste0("Number of columns in df_mice: ", ncol(df_mice)))
log_message(paste0("Dimensions of predictor matrix: ", nrow(pred_matrix), " x ", ncol(pred_matrix)))
log_message(paste0("Length of methods vector: ", length(custom_methods)))
log_message(paste0("Length of visit sequence: ", length(visit_sequence)))

# Check alignment
if (ncol(df_mice) != length(custom_methods)) {
  log_message("WARNING: Number of columns doesn't match length of methods vector!")
}
if (ncol(df_mice) != nrow(pred_matrix) || ncol(df_mice) != ncol(pred_matrix)) {
  log_message("WARNING: Predictor matrix dimensions don't match data dimensions!")
}

# Show what will be imputed
log_message("\nVariables in visit sequence:")
print(visit_sequence)

# CRITICAL CHECK: Verify outcome_VA_logMAR setup
if ("outcome_VA_logMAR" %in% names(df_mice)) {
  n_miss_outcome <- sum(is.na(df_mice$outcome_VA_logMAR))
  method_outcome <- custom_methods["outcome_VA_logMAR"]
  n_preds_outcome <- sum(pred_matrix["outcome_VA_logMAR", ] > 0)
  
  log_message("\nCRITICAL: outcome_VA_logMAR status:")
  log_message(paste0("  - Missing values: ", n_miss_outcome))
  log_message(paste0("  - Method assigned: ", method_outcome))
  log_message(paste0("  - Number of predictors: ", n_preds_outcome))
  log_message(paste0("  - In visit sequence: ", "outcome_VA_logMAR" %in% visit_sequence))
  
  # Note about cohort_id removal
  log_message("  - cohort_id removed from model to avoid perfect prediction")
  
  # Check proportion missing
  pct_missing <- round(100 * n_miss_outcome / nrow(df_mice), 1)
  log_message(paste0("  - Percent missing: ", pct_missing, "%"))
}

imp_start <- Sys.time()

mice_results <- mice(
  df_mice,
  m = n_imputations,
  method = custom_methods,
  predictorMatrix = pred_matrix,
  visitSequence = visit_sequence,
  maxit = n_iterations,
  seed = seed,
  printFlag = TRUE
)

imp_time <- round(as.numeric(difftime(Sys.time(), imp_start, units = "mins")), 2)
log_message(paste0("MICE imputation completed in ", imp_time, " minutes"))

# Check if imputation actually happened
log_message("\nPost-imputation check - variables that were imputed:")
imputed_vars_actual <- names(mice_results$imp)
log_message(paste0("Number of variables actually imputed: ", length(imputed_vars_actual)))
print(imputed_vars_actual)

# Check specific variables
for (v in c("baseline_VA_logMAR", "intermediate_VA_logMAR", "outcome_VA_logMAR")) {
  if (v %in% names(mice_results$imp)) {
    log_message(paste0(v, ": WAS IMPUTED"))
  } else {
    log_message(paste0(v, ": WAS NOT IMPUTED"))
  }
}

# Check for logged events (errors during imputation)
if (!is.null(mice_results$loggedEvents)) {
  log_message("\nWARNING: Logged events during imputation:")
  print(mice_results$loggedEvents)
}

# Minimal completeness verification: first completed dataset has no missing values
first_imp <- complete(mice_results, 1)
missing_after <- colSums(is.na(first_imp))
missing_after <- missing_after[missing_after > 0]
if (length(missing_after) > 0) {
  log_message("WARNING: Missing values remain after imputation:")
  print(missing_after)
} else {
  log_message("SUCCESS: All missing data imputed in first completed dataset.")
}
```

## Post-Imputation Completeness

```{r post-imputation-completeness}
# Table of variables with remaining missingness in the first completed dataset
comp_table <- tibble(
  Variable = names(first_imp),
  Present = colSums(!is.na(first_imp)),
  Missing = colSums(is.na(first_imp))
) |>
  dplyr::mutate(MissingPct = round(Missing / nrow(first_imp) * 100, 2)) |>
  dplyr::arrange(dplyr::desc(Missing))

vars_with_missing <- comp_table |>
  dplyr::filter(Missing > 0)

if (nrow(vars_with_missing) > 0) {
  kable(vars_with_missing, caption = "Variables with missing data after imputation (first completed dataset)")
} else {
  kable(tibble(Message = "No variables with missing data after imputation (first completed dataset)"))
}
```

 

## Create Complete Datasets and Derive Variables

```{r complete-datasets}
# Extract all imputed datasets
imputed_datasets <- complete(mice_results, action = "all")

# Apply transformation functions to recreate derived variables
imputed_datasets <- lapply(1:n_imputations, function(i) {
  imp_data <- imputed_datasets[[i]]
  imp_data |>
    create_outcome_variables() |>      # outcome_va_vi_binary from logMAR
    create_age_cat() |>                # age_cat from age
    create_treatment_type() |>         # treatment_type, any_treatment
    create_dr_severity_variables()     # dr_severity from person_dr
})

# Add back cohort_id and other variables not included in imputation
df_original_full <- df_for_imputation |>
  mutate(row_id = dplyr::row_number())

# First add back cohort_id from cohort_id_original
imputed_datasets <- lapply(imputed_datasets, function(imp_data) {
  imp_data$cohort_id <- imp_data$cohort_id_original
  imp_data$cohort_id_original <- NULL  # Remove the temporary column
  imp_data
})

# Then add any other variables not included in imputation or transformations
vars_in_imputed <- names(imputed_datasets[[1]])
vars_to_add <- setdiff(names(df_original_full), c(vars_in_imputed, "row_id"))

if (length(vars_to_add) > 0) {
  imputed_datasets <- lapply(imputed_datasets, function(imp_data) {
    orig_rows <- nrow(imp_data)
    imp_data <- imp_data |>
      dplyr::left_join(
        df_original_full |>
          dplyr::select(row_id, dplyr::all_of(vars_to_add)),
        by = "row_id"
      ) |>
      dplyr::select(-row_id)
    if (nrow(imp_data) != orig_rows) stop("Join changed row count; row_id join must be 1:1")
    imp_data
  })
}

# Completeness check for PS model variables
completeness_check <- lapply(imputed_datasets, function(d) {
  sum(!complete.cases(d[, ps_model_vars]))
})
```

### Completeness Check

```{r completeness-results}
print(unlist(completeness_check))
```

## Save Imputed Datasets

```{r save-imputed}
saveRDS(mice_results, file.path(reanalysis_data_dir, "mice_results.rds"))
saveRDS(imputed_datasets, file.path(reanalysis_data_dir, "imputed_datasets.rds"))
saveRDS(imputed_datasets[[1]], file.path(reanalysis_data_dir, "imputed_dataset_1.rds"))
```

**Saved `r n_imputations` imputed datasets to:** `r reanalysis_data_dir`

## Summary

```{r summary}
total_vars <- ncol(df_mice)
id_vars <- sum(c("row_id", "e_mrn_deidentified") %in% names(df_mice))
substantive_vars <- total_vars - id_vars

summary_table <- tibble(
  Metric = c(
    "Original observations",
    "Total variables in dataset",
    "ID variables (excluded from model)",
    "Substantive variables in imputation model",
    "Variables with missing data",
    "Variables actually imputed",
    "Number of imputations",
    "Maximum missing percentage",
    "Imputation iterations"
  ),
  Value = c(
    nrow(df_mice),
    total_vars,
    id_vars,
    substantive_vars,
    sum(mice_results$nmis > 0),
    length(names(mice_results$nmis)[mice_results$nmis > 0]),
    n_imputations,
    paste0(round(max(mice_results$nmis/nrow(df_mice)) * 100, 1), "%"),
    mice_results$iteration
  )
)

summary_table |>
  kable(caption = "Multiple imputation summary")

imputed_vars <- names(mice_results$nmis)[mice_results$nmis > 0]
print(imputed_vars)

log_message("Multiple imputation analysis completed successfully")
log_message(paste0("Total imputed datasets created: ", n_imputations))
final_log <- finalize_log(success = TRUE)
```

**Log file location:** `r final_log`

## Next Steps

Run `reanalysis-3-imputation_diagnostics.qmd` to assess imputation quality.

 
