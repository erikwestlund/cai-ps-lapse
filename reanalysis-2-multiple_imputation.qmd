---
title: "Reanalysis Step 2: Multiple Imputation"
subtitle: "Imputing missing values using mice package"
author: "Erik Westlund"
date: "`r Sys.Date()`"
format: html
---

## Setup

```{r setup}
#| include: false
source("dependencies.R")
source("functions.R")  # Load formula definitions and helper functions
seed <- 2025
setup_analysis(seed = seed)

# Additional packages for imputation
library(mice)
library(VIM)
library(naniar)

# ANALYSIS MODE: "test" or "final"
# test = 2 imputations, 2 iterations (fast)
# final = 30 imputations, 20 iterations (stability achieved ~20)
analysis_mode <- "test"  # Change to "final" for production run

# Set parameters based on mode
if (analysis_mode == "test") {
  n_imputations <- 2
  n_iterations <- 2
} else if (analysis_mode == "final") {
  n_imputations <- 30
  n_iterations <- 20
} else {
  stop("Invalid analysis_mode. Must be 'test' or 'final'")
}
```

**Running in `r toupper(analysis_mode)` mode:**  
- **Imputations:** `r n_imputations`  
- **Iterations:** `r n_iterations`

## Load Prepared Data

```{r load-data}
# Load the prepared dataset from Step 1
df_for_imputation <- readRDS(file.path(reanalysis_data_dir, "df_for_imputation.rds"))
variable_lists <- readRDS(file.path(reanalysis_data_dir, "variable_lists.rds"))

ps_model_vars <- variable_lists$ps_model_vars
outcome_model_vars <- variable_lists$outcome_model_vars
```

## Create Fellow Eye Variables

```{r create-fellow-eye-vars}
# Identify patients with both eyes and create fellow eye predictors
# This leverages the correlation between eyes from the same patient
# to improve imputation plausibility

df_with_fellow <- df_for_imputation |>
  group_by(e_mrn_deidentified) |>
  mutate(
    n_eyes = n(),
    has_fellow = n_eyes == 2,
    eye_index = row_number(),
    
    # Get fellow eye values (NA if patient has only 1 eye)
    # Using [3 - eye_index] to get the other eye (works for 2 eyes: eye 1 gets eye 2, eye 2 gets eye 1)
    fellow_baseline_VA = if_else(n_eyes == 2, 
                                 baseline_VA_logMAR[3 - eye_index], 
                                 NA_real_),
    fellow_intermediate_VA = if_else(n_eyes == 2,
                                    intermediate_VA_logMAR[3 - eye_index],
                                    NA_real_),
    fellow_outcome_VA = if_else(n_eyes == 2,
                               outcome_VA_logMAR[3 - eye_index],
                               NA_real_),
    fellow_lapsed = if_else(n_eyes == 2,
                           ever_lapse_binary[3 - eye_index],
                           NA_real_),
    # Note: fellow_dr needs special handling to maintain factor structure
    fellow_dr_numeric = if_else(n_eyes == 2,
                               person_dr[3 - eye_index],
                               NA_real_),
    
    # Patient-level summaries (same for both eyes of a patient)
    patient_worst_baseline = max(baseline_VA_logMAR, na.rm = TRUE),
    patient_best_baseline = min(baseline_VA_logMAR, na.rm = TRUE),
    patient_ever_lapsed = max(ever_lapse_binary, na.rm = TRUE)
  ) |>
  ungroup() |>
  mutate(
    # Handle Inf values from max/min with all NAs
    patient_worst_baseline = if_else(is.infinite(patient_worst_baseline), NA_real_, patient_worst_baseline),
    patient_best_baseline = if_else(is.infinite(patient_best_baseline), NA_real_, patient_best_baseline),
    
    # Convert fellow_dr_numeric to ordered factor matching person_dr structure
    fellow_dr = factor(fellow_dr_numeric, levels = c(0, 1, 2),
                      labels = c("No_DR", "NPDR", "PDR"),
                      ordered = TRUE)
  ) |>
  select(-fellow_dr_numeric)  # Remove the temporary numeric version

# Summary of eye pairing
n_patients <- n_distinct(df_with_fellow$e_mrn_deidentified)
n_single_eyes <- sum(df_with_fellow$n_eyes == 1)
n_paired_eyes <- sum(df_with_fellow$n_eyes == 2)

# Log patient/eye summary
log_message("Patient/Eye Summary:")
log_message(sprintf("- Total patients: %d", n_patients))
log_message(sprintf("- Patients with 1 eye: %d (%.1f%%)", 
            n_single_eyes, 100 * n_single_eyes / nrow(df_with_fellow)))
log_message(sprintf("- Patients with 2 eyes: %d (%.1f%%)", 
            n_paired_eyes/2, 100 * n_paired_eyes / nrow(df_with_fellow)))
log_message(sprintf("- Total eyes: %d", nrow(df_with_fellow)))

# Display summary for output
patient_eye_summary <- tibble(
  Category = c("Total patients", "Patients with 1 eye", "Patients with 2 eyes", "Total eyes"),
  N = c(n_patients, n_single_eyes, n_paired_eyes/2, nrow(df_with_fellow)),
  Percent = c(NA, 100 * n_single_eyes / nrow(df_with_fellow), 
              100 * n_paired_eyes / nrow(df_with_fellow), NA)
)
kable(patient_eye_summary, caption = "Patient/Eye Distribution", digits = 1)

# Check fellow eye data availability
fellow_summary <- df_with_fellow |>
  filter(n_eyes == 2) |>
  summarise(
    n_fellow_baseline = sum(!is.na(fellow_baseline_VA)),
    n_fellow_intermediate = sum(!is.na(fellow_intermediate_VA)),
    n_fellow_outcome = sum(!is.na(fellow_outcome_VA)),
    pct_fellow_baseline = round(100 * n_fellow_baseline / n(), 1),
    pct_fellow_intermediate = round(100 * n_fellow_intermediate / n(), 1),
    pct_fellow_outcome = round(100 * n_fellow_outcome / n(), 1)
  )

# Log fellow eye data availability
log_message("Among paired eyes, fellow eye data availability:")
log_message(sprintf("- Fellow baseline VA: %.1f%%", fellow_summary$pct_fellow_baseline))
log_message(sprintf("- Fellow intermediate VA: %.1f%%", fellow_summary$pct_fellow_intermediate))
log_message(sprintf("- Fellow outcome VA: %.1f%%", fellow_summary$pct_fellow_outcome))

# Display as table
fellow_availability <- tibble(
  Measure = c("Fellow baseline VA", "Fellow intermediate VA", "Fellow outcome VA"),
  Percent_Available = c(fellow_summary$pct_fellow_baseline, 
                        fellow_summary$pct_fellow_intermediate, 
                        fellow_summary$pct_fellow_outcome)
)
kable(fellow_availability, caption = "Fellow Eye Data Availability (Among Paired Eyes)", digits = 1)

# Use this enhanced dataset for imputation
df_for_imputation <- df_with_fellow
```

## Define Variables for Imputation

```{r define-imputation-vars}
# Variables to include in imputation model
# Include: outcome, exposure, all covariates source variables only
# Derived variables will be recreated post-imputation

# Core analysis variables - SOURCE ONLY
imputation_vars <- c(
  "e_mrn_deidentified",
  
  # Temporal VA variables
  "cohort_id",  # Data indicator only - not used as predictor
  "baseline_VA_logMAR",  # Baseline VA
  "intermediate_VA_logMAR",  # Intermediate follow-up VA (for excluded cohort)
  "outcome_VA_logMAR",  # 2-year outcome (true for submitted, missing for excluded)
  # NOT outcome_va_vi_binary - derived from logMAR >= 0.3
  
  # Exposure
  "ever_lapse_binary",
  
  # Demographics/Clinical
  "gender_cat",
  "race_ethnic_cat",
  "insurance_cat",
  "age",  # Continuous age (source)
  # NOT age_cat - derived from cut(age)
  "CCI",
  "DCSI",
  
  # Treatment indicators - ALL SOURCES
  "other_inject",
  "anti_VEGF",
  "focal_laser_flag",
  "PRP_flag",
  # NOT treatment_type or any_treatment - derived from these 4
  
  # Comorbidities (already recoded to 0/1)
  "glaucoma_bef_hitplus_cat",
  "otherretina_bef_hitplus_cat",
  "catsurg_before_hitplus_cat",
  
  # DR severity - use person_dr (created from No_DR/NPDR/PDR)
  "person_dr",  # Numeric 0/1/2
  # NOT dr_severity or person_dr_severity - derived from person_dr
  
  # Fellow eye predictors (if available)
  "fellow_baseline_VA",
  "fellow_intermediate_VA",
  "fellow_outcome_VA",
  "fellow_lapsed",
  "fellow_dr",
  "n_eyes",
  "has_fellow",
  "patient_worst_baseline",
  "patient_best_baseline",
  "patient_ever_lapsed"
)

df_mice <- df_for_imputation |>
  mutate(
    # Create a unique row identifier to preserve exact row matching
    row_id = row_number()
  ) |>
  dplyr::select(row_id, dplyr::all_of(imputation_vars)) |>
  mutate(
    # Convert person_dr to ordered factor for polr imputation method
    person_dr = factor(person_dr, levels = c(0, 1, 2), 
                      labels = c("No_DR", "NPDR", "PDR"),
                      ordered = TRUE),
    # Lock factor levels for categorical variables to ensure consistency
    cohort_id = factor(cohort_id),  # Ensure cohort_id is a factor
    gender_cat = factor(gender_cat),
    race_ethnic_cat = factor(race_ethnic_cat),
    insurance_cat = factor(insurance_cat)
  )
```

## Setup Imputation Model

```{r setup-mice}
# Initialize mice
# First, do a dry run to check the imputation setup
mice_dry <- mice(df_mice, maxit = 0, printFlag = FALSE)

# Imputation model summary
miss_vars <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  Pct_Missing = round(mice_dry$nmis/nrow(df_mice) * 100, 1)
) |>
  filter(N_Missing > 0) |>
  arrange(desc(N_Missing))
```

### Initial Imputation Model Summary

**Total variables in dataset:** `r ncol(df_mice)`  
**Variables to be imputed:** `r sum(mice_dry$nmis > 0)`  
**Total missing values:** `r sum(mice_dry$nmis)`  

**Missing data by variable:**
```{r missing-vars-table}
kable(miss_vars)

method_table <- data.frame(
  Variable = names(mice_dry$method),
  Method = mice_dry$method,
  stringsAsFactors = FALSE
) |>
  filter(Method != "")
```

**Initial imputation methods by variable:**
```{r method-table}
kable(method_table)

# Customize imputation methods as needed
custom_methods <- mice_dry$method

# Temporal VA variables
custom_methods["baseline_VA_logMAR"] <- "pmm"  # Impute if missing
custom_methods["intermediate_VA_logMAR"] <- "pmm"  # IMPUTE intermediate values
custom_methods["outcome_VA_logMAR"] <- "pmm"  # Impute 2-year outcomes
custom_methods["cohort_id"] <- ""  # Never impute - data management indicator only

# Other continuous variables
custom_methods["CCI"] <- "pmm"  # Predictive mean matching for count data
custom_methods["DCSI"] <- "pmm"  # Predictive mean matching for count data
custom_methods["age"] <- "pmm"

# Use proportional odds model for ordinal person_dr (0/1/2)
custom_methods["person_dr"] <- "polr"  # Ordinal logistic regression

# Use logistic regression for binary variables
custom_methods["catsurg_before_hitplus_cat"] <- "logreg"

# Use polytomous regression for categorical variables with >2 levels
custom_methods["race_ethnic_cat"] <- "polyreg"
custom_methods["insurance_cat"] <- "polyreg"

# Don't impute these variables
# Method = "" means: don't impute (but still use as predictor EXCEPT for IDs)
custom_methods["row_id"] <- ""  # Row ID - never impute, never use as predictor; see below.
custom_methods["e_mrn_deidentified"] <- ""  # Patient ID - never impute, never use as predictor; see below.

# Fellow eye variables should not be imputed (they are derived from existing data)
# NOTE: fellow_outcome_VA may show collinearity warning with outcome_VA_logMAR
# This is expected - they have identical missingness patterns (both NA for excluded cohort)
custom_methods["fellow_outcome_VA"] <- ""
custom_methods["fellow_baseline_VA"] <- ""
custom_methods["fellow_intermediate_VA"] <- ""
# custom_methods["fellow_lapsed"] <- ""  # REMOVED - collinear with lapse status
custom_methods["fellow_dr"] <- ""
custom_methods["n_eyes"] <- ""
# custom_methods["has_fellow"] <- ""  # REMOVED - collinear with n_eyes
custom_methods["patient_worst_baseline"] <- ""
custom_methods["patient_best_baseline"] <- ""
# custom_methods["patient_ever_lapsed"] <- ""  # REMOVED - collinear with ever_lapse_binary

# Variables that are complete (no missing data) - set method but won't actually be imputed
# Setting methods ensures correct measurement level is used IF they had missing data
custom_methods["ever_lapse_binary"] <- "logreg"  # Binary - complete
custom_methods["glaucoma_bef_hitplus_cat"] <- "logreg"  # Binary - already recoded to 0/1
custom_methods["otherretina_bef_hitplus_cat"] <- "logreg"  # Binary - already recoded to 0/1
custom_methods["gender_cat"] <- "logreg"  # Binary categorical - likely complete
custom_methods["other_inject"] <- "logreg"  # Binary - likely complete
custom_methods["anti_VEGF"] <- "logreg"  # Binary - likely complete  
custom_methods["focal_laser_flag"] <- "logreg"  # Binary - likely complete
custom_methods["PRP_flag"] <- "logreg"  # Binary - likely complete

# Note: Variables with complete data won't be imputed even if they have a method assigned
# The method specification ensures proper measurement level if imputation were needed

# Check predictor matrix (which variables predict which)
pred_matrix <- mice_dry$predictorMatrix

# Don't use IDs as predictors AND don't impute them
pred_matrix[, "e_mrn_deidentified"] <- 0
pred_matrix["e_mrn_deidentified", ] <- 0
pred_matrix[, "row_id"] <- 0
pred_matrix["row_id", ] <- 0

# TEMPORAL STRUCTURE RULES
# 1. Baseline can predict intermediate and outcome
pred_matrix["intermediate_VA_logMAR", "baseline_VA_logMAR"] <- 1
pred_matrix["outcome_VA_logMAR", "baseline_VA_logMAR"] <- 1

# 2. Intermediate can predict outcome
# NOTE: MICE predictor matrix only uses 0/1, not weights.
# To prioritize intermediate VA over baseline for outcome prediction:
# - Both are included as predictors (temporal proximity naturally helps)
# - PMM will naturally weight closer timepoints more heavily
# - Alternative: Could create interaction terms or use method="norm.boot" with custom weights
pred_matrix["outcome_VA_logMAR", "intermediate_VA_logMAR"] <- 1

# 3. CRITICAL: Prevent reverse-time prediction
pred_matrix["intermediate_VA_logMAR", "outcome_VA_logMAR"] <- 0  # Outcome cannot predict intermediate
pred_matrix["baseline_VA_logMAR", "outcome_VA_logMAR"] <- 0  # Outcome cannot predict baseline
pred_matrix["baseline_VA_logMAR", "intermediate_VA_logMAR"] <- 0  # Intermediate cannot predict baseline

# Cohort_id should not be predicted by anything AND should not predict anything
pred_matrix["cohort_id", ] <- 0  # Not predicted
pred_matrix[, "cohort_id"] <- 0  # Not a predictor

# Don't use variables as their own predictors
diag(pred_matrix) <- 0

# Ensure exposure is used as predictor for outcomes
pred_matrix[, "ever_lapse_binary"] <- 1
pred_matrix["ever_lapse_binary", "ever_lapse_binary"] <- 0

# DR severity predicts visual acuity at all timepoints
if ("person_dr" %in% colnames(pred_matrix)) {
  pred_matrix["baseline_VA_logMAR", "person_dr"] <- 1
  pred_matrix["intermediate_VA_logMAR", "person_dr"] <- 1
  pred_matrix["outcome_VA_logMAR", "person_dr"] <- 1
}

# FELLOW EYE STRUCTURE
# Fellow eye outcomes strongly predict index eye outcomes (correlation typically 0.7-0.9)
# NOTE: MICE predictor matrix only uses 0/1, not weights. 1 = used as predictor, 0 = not used
if ("fellow_outcome_VA" %in% colnames(pred_matrix)) {
  # Fellow eye visual acuity predicts same timepoint
  pred_matrix["outcome_VA_logMAR", "fellow_outcome_VA"] <- 1
  pred_matrix["baseline_VA_logMAR", "fellow_baseline_VA"] <- 1  
  pred_matrix["intermediate_VA_logMAR", "fellow_intermediate_VA"] <- 1
  
  # Fellow baseline also helps predict later timepoints
  pred_matrix["outcome_VA_logMAR", "fellow_baseline_VA"] <- 1
  pred_matrix["intermediate_VA_logMAR", "fellow_baseline_VA"] <- 1
  
  # DR severity correlation between eyes
  if ("person_dr" %in% rownames(pred_matrix)) {
    pred_matrix["person_dr", "fellow_dr"] <- 1
  }
  
  # Don't let fellow eye variables be predicted by anything
  pred_matrix[c("fellow_outcome_VA", "fellow_baseline_VA", "fellow_intermediate_VA", 
                "fellow_lapsed", "fellow_dr"), ] <- 0
  
  # Don't let fellow eye variables be their own predictors
  pred_matrix["fellow_outcome_VA", "fellow_outcome_VA"] <- 0
  pred_matrix["fellow_baseline_VA", "fellow_baseline_VA"] <- 0
  pred_matrix["fellow_intermediate_VA", "fellow_intermediate_VA"] <- 0
}

# Patient-level variables can predict eye-level outcomes (but not strongly)
if ("patient_worst_baseline" %in% colnames(pred_matrix)) {
  pred_matrix[, "patient_worst_baseline"] <- 1
  pred_matrix[, "patient_best_baseline"] <- 1
  pred_matrix[, "patient_ever_lapsed"] <- 1
  
  # But don't predict these variables
  pred_matrix["patient_worst_baseline", ] <- 0
  pred_matrix["patient_best_baseline", ] <- 0
  pred_matrix["patient_ever_lapsed", ] <- 0
}

# n_eyes and has_fellow are just indicators, not predictors
if ("n_eyes" %in% colnames(pred_matrix)) {
  pred_matrix[, "n_eyes"] <- 0
  pred_matrix["n_eyes", ] <- 0
  pred_matrix[, "has_fellow"] <- 0
  pred_matrix["has_fellow", ] <- 0
}

```

### Final Imputation Model Configuration

```{r final-model-config}

# Get actual missing data information
missing_info <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  stringsAsFactors = FALSE
)

# Summary of methods
final_methods <- data.frame(
  Variable = names(custom_methods),
  Method = custom_methods,
  Type = dplyr::case_when(
    custom_methods == "" ~ "Excluded (IDs - not used as predictor)",
    custom_methods == "pmm" ~ "Predictive mean matching",
    custom_methods == "polr" ~ "Proportional odds regression",
    custom_methods == "logreg" ~ "Logistic regression",
    custom_methods == "polyreg" ~ "Polytomous regression",
    TRUE ~ custom_methods
  ),
  stringsAsFactors = FALSE
) |>
  left_join(missing_info, by = "Variable") |>
  mutate(
    Will_Be_Imputed = N_Missing > 0 & Method != "",
    Role = case_when(
      Variable %in% c("row_id", "e_mrn_deidentified") ~ "ID (excluded)",
      N_Missing == 0 & Method != "" ~ "Complete predictor",
      N_Missing > 0 & Method != "" ~ "To be imputed",
      TRUE ~ "Other"
    )
  )

# Sort to show meaningful groupings
final_methods <- final_methods |>
  dplyr::arrange(Role == "ID (excluded)", N_Missing == 0, Variable)

# Variables that will ACTUALLY be imputed (have missing data AND a method)
vars_to_impute <- final_methods |>
  filter(Will_Be_Imputed) |>
  pull(Variable)
```

**Imputation methods and missing data by variable:**
```{r final-methods-table}
final_methods |>
  select(Variable, Type, N_Missing, Role) |>
  kable(col.names = c("Variable", "Method Type", "Missing Values", "Role in Imputation"))
```

**Variables that will ACTUALLY be imputed** (have missing data, `r length(vars_to_impute)` total):
```{r vars-to-impute}
if (length(vars_to_impute) > 0) {
  data.frame(
    Variable = vars_to_impute,
    Missing_Count = final_methods |> 
      filter(Variable %in% vars_to_impute) |> 
      pull(N_Missing)
  ) |>
  kable()
} else {
  no_imputation_msg <- "No variables require imputation (all data complete)"
  print(no_imputation_msg)
}

# Show complete variables with methods assigned
complete_with_methods <- final_methods |>
  filter(N_Missing == 0 & Method != "") |>
  select(Variable, Type)
```

**Complete variables with imputation methods assigned** (`r nrow(complete_with_methods)` total):
These variables have no missing data and won't be imputed, but have methods specified to ensure proper measurement level:
```{r complete-vars-table}
if (nrow(complete_with_methods) > 0) {
  kable(complete_with_methods, col.names = c("Variable", "Method Type"))
} else {
  no_complete_msg <- "No complete variables with methods assigned"
  print(no_complete_msg)
}

# Show predictor matrix summary
# Get the number of predictors for each variable
predictors_per_var <- rowSums(pred_matrix)

# Separate by variable type
id_vars_pred <- predictors_per_var[c("row_id", "e_mrn_deidentified")]
imputed_vars_pred <- predictors_per_var[vars_to_impute]
other_vars_pred <- predictors_per_var[!names(predictors_per_var) %in% c("row_id", "e_mrn_deidentified", vars_to_impute)]

# Calculate meaningful statistics
n_predictors_for_imputed <- if(length(imputed_vars_pred) > 0) unique(imputed_vars_pred)[1] else NA
predictors <- names(which(colSums(pred_matrix) > 0))

# Verify IDs are excluded
ids_excluded <- all(pred_matrix[, "row_id"] == 0) & all(pred_matrix[, "e_mrn_deidentified"] == 0)
```

### Predictor Matrix Summary

**Number of predictors used:**
- For variables being imputed: **`r if(!is.na(n_predictors_for_imputed)) n_predictors_for_imputed else 0`** predictors each
- For ID variables: **0** predictors (excluded from imputation)

**ID variables properly excluded from predictors:** `r if(ids_excluded) "Yes" else "No"`

**Variables used as predictors** (`r length(predictors)` total):
```{r predictor-list}
if ("row_id" %in% predictors || "e_mrn_deidentified" %in% predictors) {
  warning("WARNING: ID variables are being used as predictors! This should not happen.")
}
print(predictors)
```

### Visit Sequence

```{r visit-sequence}
# Define the order of imputation to respect temporal flow
# Impute earlier timepoints before later ones
visit_sequence <- c()

# First impute baseline if needed
if ("baseline_VA_logMAR" %in% vars_to_impute) {
  visit_sequence <- c(visit_sequence, "baseline_VA_logMAR")
}

# Then impute intermediate
if ("intermediate_VA_logMAR" %in% vars_to_impute) {
  visit_sequence <- c(visit_sequence, "intermediate_VA_logMAR")
}

# Then impute outcome
if ("outcome_VA_logMAR" %in% vars_to_impute) {
  visit_sequence <- c(visit_sequence, "outcome_VA_logMAR")
}

# Add other variables that need imputation
other_vars_to_impute <- vars_to_impute[!vars_to_impute %in% 
                                       c("baseline_VA_logMAR", 
                                         "intermediate_VA_logMAR", 
                                         "outcome_VA_logMAR")]
visit_sequence <- c(visit_sequence, other_vars_to_impute)

# Store for display
imputation_order <- paste(visit_sequence, collapse = ", ")
```

**Imputation order (respecting temporal structure):** `r imputation_order`

### Imputation Parameters

```{r imputation-params}
imp_params <- data.frame(
  Parameter = c("Mode", "Number of imputations (m)", "Max iterations (maxit)", "Random seed", "Visit sequence"),
  Value = c(analysis_mode, n_imputations, n_iterations, seed, "Temporal order enforced")
)
kable(imp_params)
```

## Run Multiple Imputation

```{r run-imputation}
# Run mice imputation
# Note: Parameters are set based on analysis_mode in setup
time_estimate <- if(analysis_mode == "test") "a few minutes" else "15-30 minutes or more"
```

**Starting multiple imputation...**

- Mode: `r analysis_mode`
- Imputations: `r n_imputations`
- Iterations: `r n_iterations`
- Estimated time: `r time_estimate`

```{r mice-run}
# Initialize logging
log_file <- init_log("multiple_imputation")
log_message(paste0("Analysis mode: ", analysis_mode))
log_message(paste0("Number of imputations: ", n_imputations))
log_message(paste0("Number of iterations per imputation: ", n_iterations))
log_message(paste0("Number of observations: ", nrow(df_mice)))
log_message(paste0("Variables with missing data: ", sum(colSums(is.na(df_mice)) > 0)))

log_message("Starting MICE imputation process...")

# Expected warnings about collinearity:
# 1. e_mrn_deidentified: Constant (patient ID) - expected, not used as predictor
# 2. outcome_VA_logMAR & fellow_outcome_VA: Identical missingness patterns (both NA for excluded cohort)
#    This is expected and OK - they're measuring different eyes but missing for same reason
# 3. Variables removed to avoid true collinearity: has_fellow, patient_ever_lapsed, fellow_lapsed
#    These were redundant with other variables in the model

imp_start <- Sys.time()

mice_results <- mice(
  df_mice,
  m = n_imputations,
  method = custom_methods,
  predictorMatrix = pred_matrix,
  visitSequence = visit_sequence,  # Enforce temporal order
  maxit = n_iterations,  # Uses n_iterations from setup
  seed = 2025,
  printFlag = TRUE
)

imp_time <- round(as.numeric(difftime(Sys.time(), imp_start, units = "mins")), 2)
log_message(paste0("MICE imputation completed in ", imp_time, " minutes"))

# Check convergence
plot(mice_results)
```

## Imputation Diagnostics

**Note:** In the stripplots below, the leftmost column (labeled 1) shows the **original observed data** with missing values. Columns 2 through `r n_imputations + 1` show the imputed datasets.

```{r imputation-diagnostics}
# Check imputed values for key variables
# In mice stripplots: .imp = 1 is original data, .imp = 2+ are imputations

# CCI - compare observed vs imputed
if(sum(is.na(df_mice$CCI)) > 0) {
  # Density plot: Blue = observed data, Red = imputed values
  densityplot(mice_results, ~ CCI, 
              main = "Charlson Comorbidity Index (CCI)") |> print()
  
  # Stripplot: Column 1 = original data, Columns 2+ = imputed datasets
  stripplot(mice_results, CCI ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "CCI Distribution: Original vs Imputed") |> print()
}

# DCSI - compare observed vs imputed  
if(sum(is.na(df_mice$DCSI)) > 0) {
  densityplot(mice_results, ~ DCSI,
              main = "Diabetes Complications Severity Index (DCSI)") |> print()
  
  stripplot(mice_results, DCSI ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "DCSI Distribution: Original vs Imputed") |> print()
}

# Baseline VA - compare observed vs imputed
if(sum(is.na(df_mice$baseline_VA_logMAR)) > 0) {
  densityplot(mice_results, ~ baseline_VA_logMAR,
              main = "Baseline Visual Acuity (logMAR)") |> print()
  
  stripplot(mice_results, baseline_VA_logMAR ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "Baseline VA Distribution: Original vs Imputed") |> print()
}

# Intermediate VA - compare observed vs imputed
if(sum(is.na(df_mice$intermediate_VA_logMAR)) > 0) {
  densityplot(mice_results, ~ intermediate_VA_logMAR,
              main = "Intermediate Visual Acuity (logMAR)") |> print()
  
  stripplot(mice_results, intermediate_VA_logMAR ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "Intermediate VA Distribution: Original vs Imputed") |> print()
}

# Outcome VA - compare observed vs imputed
if(sum(is.na(df_mice$outcome_VA_logMAR)) > 0) {
  densityplot(mice_results, ~ outcome_VA_logMAR,
              main = "Outcome Visual Acuity at 2 Years (logMAR)") |> print()
  
  stripplot(mice_results, outcome_VA_logMAR ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "2-Year Outcome VA Distribution: Original vs Imputed") |> print()
}

# Person DR - compare observed vs imputed (categorical)
if(sum(is.na(df_mice$person_dr)) > 0) {
  # For categorical variables, check proportions across imputations
  # Extract each imputation and tabulate
  dr_props <- sapply(1:n_imputations, function(i) {
    imp_data <- complete(mice_results, i)
    prop.table(table(imp_data$person_dr))
  })
  
  # Create summary table
  dr_summary <- data.frame(
    Category = c("No_DR", "NPDR", "PDR"),
    Mean_Proportion = c(round(mean(dr_props[1,]), 3), 
                       round(mean(dr_props[2,]), 3),
                       round(mean(dr_props[3,]), 3)),
    SD = c(round(sd(dr_props[1,]), 3),
           round(sd(dr_props[2,]), 3), 
           round(sd(dr_props[3,]), 3))
  )
  kable(dr_summary, caption = "DR severity proportions across imputations")
  
  # Visual check if stripplot works with factors
  tryCatch({
    stripplot(mice_results, person_dr ~ .imp, pch = 20, cex = 1.2) |> print()
  }, error = function(e) {
    # Note: Stripplot not available for categorical person_dr
  })
}

# Check imputation quality for categorical variables
# Cataract surgery
if(sum(is.na(df_mice$catsurg_before_hitplus_cat)) > 0) {
  # Extract proportions for each imputation
  cat_props <- sapply(1:n_imputations, function(i) {
    imp_data <- complete(mice_results, i)
    prop.table(table(imp_data$catsurg_before_hitplus_cat))
  })
  
  # Create summary table for cataract surgery proportions
  if(is.matrix(cat_props)) {
    cat_summary <- data.frame(
      Level = rownames(cat_props),
      Mean_Proportion = apply(cat_props, 1, mean) |> round(3),
      SD = apply(cat_props, 1, sd) |> round(3)
    )
  } else {
    cat_summary <- data.frame(
      Level = "Cataract Surgery",
      Mean_Proportion = round(mean(cat_props), 3),
      SD = round(sd(cat_props), 3)
    )
  }
  kable(cat_summary, caption = "Cataract surgery proportions across imputations")
}

# Fellow Eye Correlation Check
# For patients with both eyes, check correlation between eyes
if (sum(df_mice$n_eyes == 2, na.rm = TRUE) > 0) {
  
  # Extract first imputed dataset
  imp_data_1 <- complete(mice_results, 1)
  
  # Get bilateral patients
  bilateral_patients <- imp_data_1 |>
    filter(n_eyes == 2) |>
    arrange(e_mrn_deidentified)  # Sort by patient ID
  
  # Check correlation for baseline VA
  # Use slice_head and slice_tail to get first and second eye for each patient
  baseline_pairs <- bilateral_patients |>
    group_by(e_mrn_deidentified) |>
    summarise(
      eye1_baseline = first(baseline_VA_logMAR),
      eye2_baseline = last(baseline_VA_logMAR),
      .groups = "drop"
    ) |>
    filter(!is.na(eye1_baseline) & !is.na(eye2_baseline))
  
  baseline_cor <- cor(baseline_pairs$eye1_baseline, baseline_pairs$eye2_baseline)
  
  # Check correlation for outcome VA 
  outcome_pairs <- bilateral_patients |>
    group_by(e_mrn_deidentified) |>
    summarise(
      eye1_outcome = first(outcome_VA_logMAR),
      eye2_outcome = last(outcome_VA_logMAR),
      .groups = "drop"
    ) |>
    filter(!is.na(eye1_outcome) & !is.na(eye2_outcome))
  
  outcome_cor <- cor(outcome_pairs$eye1_outcome, outcome_pairs$eye2_outcome)
  
  # Summary table
  fellow_cor_summary <- data.frame(
    Measure = c("Baseline VA", "Outcome VA"),
    N_Pairs = c(nrow(baseline_pairs), nrow(outcome_pairs)),
    Correlation = c(round(baseline_cor, 3), round(outcome_cor, 3)),
    Expected_Range = c("0.7-0.9", "0.7-0.9"),
    Status = c(
      ifelse(baseline_cor >= 0.7 & baseline_cor <= 0.9, "✓ Within expected", "⚠ Outside expected"),
      ifelse(outcome_cor >= 0.7 & outcome_cor <= 0.9, "✓ Within expected", "⚠ Outside expected")
    )
  )
  
  kable(fellow_cor_summary, caption = "Fellow eye correlation in imputed data")
  
  # Visual check - scatter plot
  par(mfrow = c(1, 2))
  
  # Baseline VA correlation plot
  plot(baseline_pairs$eye1_baseline, baseline_pairs$eye2_baseline,
       xlab = "Eye 1 Baseline VA (logMAR)",
       ylab = "Eye 2 Baseline VA (logMAR)",
       main = paste0("Baseline VA Correlation (r = ", round(baseline_cor, 2), ")"),
       pch = 19, col = rgb(0, 0, 0, 0.5))
  abline(lm(eye2_baseline ~ eye1_baseline, data = baseline_pairs), col = "red", lwd = 2)
  
  # Outcome VA correlation plot
  plot(outcome_pairs$eye1_outcome, outcome_pairs$eye2_outcome,
       xlab = "Eye 1 Outcome VA (logMAR)",
       ylab = "Eye 2 Outcome VA (logMAR)",
       main = paste0("Outcome VA Correlation (r = ", round(outcome_cor, 2), ")"),
       pch = 19, col = rgb(0, 0, 0, 0.5))
  abline(lm(eye2_outcome ~ eye1_outcome, data = outcome_pairs), col = "red", lwd = 2)
  
  par(mfrow = c(1, 1))
  
  # Check correlation across all imputations
  all_cors <- sapply(1:n_imputations, function(i) {
    imp_data <- complete(mice_results, i)
    bilateral <- imp_data |> filter(n_eyes == 2)
    
    # Baseline correlation
    base_pairs <- bilateral |>
      group_by(e_mrn_deidentified) |>
      summarise(
        eye1 = first(baseline_VA_logMAR),
        eye2 = last(baseline_VA_logMAR),
        .groups = "drop"
      ) |>
      filter(!is.na(eye1) & !is.na(eye2))
    
    base_cor <- if(nrow(base_pairs) > 0) cor(base_pairs$eye1, base_pairs$eye2) else NA
    
    # Outcome correlation
    out_pairs <- bilateral |>
      group_by(e_mrn_deidentified) |>
      summarise(
        eye1 = first(outcome_VA_logMAR),
        eye2 = last(outcome_VA_logMAR),
        .groups = "drop"
      ) |>
      filter(!is.na(eye1) & !is.na(eye2))
    
    out_cor <- if(nrow(out_pairs) > 0) cor(out_pairs$eye1, out_pairs$eye2) else NA
    
    c(baseline_cor = base_cor, outcome_cor = out_cor)
  })
  
  # Summary of correlations across imputations
  cor_summary_all <- data.frame(
    Measure = c("Baseline VA", "Outcome VA"),
    Mean_Correlation = c(
      round(mean(all_cors["baseline_cor",], na.rm = TRUE), 3),
      round(mean(all_cors["outcome_cor",], na.rm = TRUE), 3)
    ),
    SD_Correlation = c(
      round(sd(all_cors["baseline_cor",], na.rm = TRUE), 3),
      round(sd(all_cors["outcome_cor",], na.rm = TRUE), 3)
    ),
    Min = c(
      round(min(all_cors["baseline_cor",], na.rm = TRUE), 3),
      round(min(all_cors["outcome_cor",], na.rm = TRUE), 3)
    ),
    Max = c(
      round(max(all_cors["baseline_cor",], na.rm = TRUE), 3),
      round(max(all_cors["outcome_cor",], na.rm = TRUE), 3)
    )
  )
  
  kable(cor_summary_all, caption = "Fellow eye correlations across all imputations")
}

# Clinical Plausibility Check for Imputed Values
log_message("Checking clinical plausibility of imputed values")

# Extract observed and imputed ranges for each variable
plausibility_checks <- list()

# Visual Acuity measures (logMAR scale)
# Clinical limits: -0.3 (exceptional vision) to 3.0 (hand motion/counting fingers)
va_vars <- c("baseline_VA_logMAR", "intermediate_VA_logMAR", "outcome_VA_logMAR")

for (var in va_vars) {
  if (sum(is.na(df_mice[[var]])) > 0) {
    # Get observed range
    obs_range <- range(df_mice[[var]], na.rm = TRUE)
    
    # Get imputed ranges across all imputations
    imp_ranges <- sapply(1:n_imputations, function(i) {
      imp_data <- complete(mice_results, i)
      # Only look at previously missing values
      was_missing <- is.na(df_mice[[var]])
      if (sum(was_missing) > 0) {
        range(imp_data[[var]][was_missing])
      } else {
        c(NA, NA)
      }
    })
    
    plausibility_checks[[var]] <- data.frame(
      Variable = var,
      Observed_Min = round(obs_range[1], 3),
      Observed_Max = round(obs_range[2], 3),
      Imputed_Min = round(min(imp_ranges[1,], na.rm = TRUE), 3),
      Imputed_Max = round(max(imp_ranges[2,], na.rm = TRUE), 3),
      Clinical_Min = -0.3,
      Clinical_Max = 3.0,
      stringsAsFactors = FALSE
    )
    
    # Check if imputed values fall within observed range
    plausibility_checks[[var]]$Within_Observed <- 
      plausibility_checks[[var]]$Imputed_Min >= plausibility_checks[[var]]$Observed_Min &
      plausibility_checks[[var]]$Imputed_Max <= plausibility_checks[[var]]$Observed_Max
    
    # Check if imputed values fall within clinical limits
    plausibility_checks[[var]]$Within_Clinical <- 
      plausibility_checks[[var]]$Imputed_Min >= plausibility_checks[[var]]$Clinical_Min &
      plausibility_checks[[var]]$Imputed_Max <= plausibility_checks[[var]]$Clinical_Max
  }
}

# Comorbidity indices (non-negative integers)
comorbidity_vars <- c("CCI", "DCSI")

for (var in comorbidity_vars) {
  if (sum(is.na(df_mice[[var]])) > 0) {
    obs_range <- range(df_mice[[var]], na.rm = TRUE)
    
    imp_ranges <- sapply(1:n_imputations, function(i) {
      imp_data <- complete(mice_results, i)
      was_missing <- is.na(df_mice[[var]])
      if (sum(was_missing) > 0) {
        range(imp_data[[var]][was_missing])
      } else {
        c(NA, NA)
      }
    })
    
    plausibility_checks[[var]] <- data.frame(
      Variable = var,
      Observed_Min = round(obs_range[1], 1),
      Observed_Max = round(obs_range[2], 1),
      Imputed_Min = round(min(imp_ranges[1,], na.rm = TRUE), 1),
      Imputed_Max = round(max(imp_ranges[2,], na.rm = TRUE), 1),
      Clinical_Min = 0,
      Clinical_Max = ifelse(var == "CCI", 37, 13),  # CCI max 37, DCSI max 13
      stringsAsFactors = FALSE
    )
    
    plausibility_checks[[var]]$Within_Observed <- 
      plausibility_checks[[var]]$Imputed_Min >= plausibility_checks[[var]]$Observed_Min &
      plausibility_checks[[var]]$Imputed_Max <= plausibility_checks[[var]]$Observed_Max
    
    plausibility_checks[[var]]$Within_Clinical <- 
      plausibility_checks[[var]]$Imputed_Min >= plausibility_checks[[var]]$Clinical_Min &
      plausibility_checks[[var]]$Imputed_Max <= plausibility_checks[[var]]$Clinical_Max
  }
}

# Combine all plausibility checks
if (length(plausibility_checks) > 0) {
  plausibility_summary <- do.call(rbind, plausibility_checks)
  rownames(plausibility_summary) <- NULL
  
  # Add status column
  plausibility_summary$Status <- ifelse(
    plausibility_summary$Within_Observed,
    "✓ Within observed range (PMM working correctly)",
    ifelse(
      plausibility_summary$Within_Clinical,
      "⚠ Outside observed but within clinical limits",
      "✗ Outside clinical limits"
    )
  )
  
  kable(plausibility_summary[, c("Variable", "Observed_Min", "Observed_Max", 
                                 "Imputed_Min", "Imputed_Max", "Status")],
        caption = "Clinical Plausibility of Imputed Values (PMM ensures values stay within observed range)")
  
  log_message(paste0("Plausibility check complete. All variables within observed range: ",
                    all(plausibility_summary$Within_Observed)))
}

# Check between-imputation variance
log_message("Checking between-imputation variance")

# Calculate variance across imputations for key outcomes
variance_checks <- sapply(va_vars, function(var) {
  if (sum(is.na(df_mice[[var]])) > 0) {
    # Get imputed values for each missing observation across all imputations
    was_missing <- which(is.na(df_mice[[var]]))
    
    if (length(was_missing) > 0) {
      imp_values <- sapply(1:n_imputations, function(i) {
        imp_data <- complete(mice_results, i)
        imp_data[[var]][was_missing]
      })
      
      # Calculate mean variance across observations
      if (is.matrix(imp_values)) {
        obs_variances <- apply(imp_values, 1, var)
        mean_var <- mean(obs_variances, na.rm = TRUE)
        min_var <- min(obs_variances, na.rm = TRUE)
        max_var <- max(obs_variances, na.rm = TRUE)
      } else {
        mean_var <- var(imp_values)
        min_var <- mean_var
        max_var <- mean_var
      }
      
      c(Mean_Variance = mean_var, Min_Variance = min_var, Max_Variance = max_var)
    } else {
      c(Mean_Variance = NA, Min_Variance = NA, Max_Variance = NA)
    }
  } else {
    c(Mean_Variance = NA, Min_Variance = NA, Max_Variance = NA)
  }
})

if (ncol(variance_checks) > 0) {
  variance_summary <- data.frame(
    Variable = colnames(variance_checks),
    Mean_Between_Imp_Variance = round(variance_checks["Mean_Variance",], 4),
    Min_Between_Imp_Variance = round(variance_checks["Min_Variance",], 4),
    Max_Between_Imp_Variance = round(variance_checks["Max_Variance",], 4),
    Status = ifelse(
      variance_checks["Mean_Variance",] > 0.001,
      "✓ Adequate variance",
      "⚠ Low variance - check predictor weights"
    )
  )
  
  kable(variance_summary, 
        caption = "Between-Imputation Variance (ensures uncertainty is preserved)")
  
  log_message(paste0("Variance check complete. Adequate variance in all variables: ",
                    all(variance_checks["Mean_Variance",] > 0.001, na.rm = TRUE)))
}
```

## MNAR Sensitivity Analysis: Delta-Shift Method

```{r mnar-sensitivity}
# Delta-shift sensitivity analysis for MNAR
# This shows how results would change if missing values were systematically different
# We do NOT apply these shifts to the main imputation - just show diagnostics

log_message("Performing MNAR sensitivity analysis (diagnostic only)")

# Define small symmetric deltas for outcome VA (in logMAR units)
# 0.1 logMAR = 1 line on eye chart
deltas <- c(-0.2, -0.1, 0, 0.1, 0.2)

# For each delta, show how the outcome distribution would shift
delta_results <- list()

for (delta in deltas) {
  # Take first imputed dataset as example
  imp_data_1 <- complete(mice_results, 1)
  
  # Identify which outcomes were imputed
  was_imputed <- is.na(df_mice$outcome_VA_logMAR)
  
  if (sum(was_imputed) > 0) {
    # Create shifted version (for diagnostic only)
    shifted_data <- imp_data_1
    shifted_data$outcome_VA_logMAR[was_imputed] <- 
      shifted_data$outcome_VA_logMAR[was_imputed] + delta
    
    # Calculate outcome statistics
    delta_results[[as.character(delta)]] <- data.frame(
      Delta = delta,
      Delta_Lines = round(delta / 0.1, 1),  # Convert to eye chart lines
      Mean_Observed = round(mean(imp_data_1$outcome_VA_logMAR[!was_imputed], na.rm = TRUE), 3),
      Mean_Imputed_Original = round(mean(imp_data_1$outcome_VA_logMAR[was_imputed], na.rm = TRUE), 3),
      Mean_Imputed_Shifted = round(mean(shifted_data$outcome_VA_logMAR[was_imputed], na.rm = TRUE), 3),
      Pct_VI_Observed = round(100 * mean(imp_data_1$outcome_VA_logMAR[!was_imputed] >= 1.0, na.rm = TRUE), 1),
      Pct_VI_Imputed_Original = round(100 * mean(imp_data_1$outcome_VA_logMAR[was_imputed] >= 1.0, na.rm = TRUE), 1),
      Pct_VI_Imputed_Shifted = round(100 * mean(shifted_data$outcome_VA_logMAR[was_imputed] >= 1.0, na.rm = TRUE), 1)
    )
  }
}

if (length(delta_results) > 0) {
  sensitivity_summary <- do.call(rbind, delta_results)
  rownames(sensitivity_summary) <- NULL
  
  # Add interpretation
  sensitivity_summary$Interpretation <- c(
    "Imputed have 2 lines better vision",
    "Imputed have 1 line better vision",
    "No systematic difference (MAR)",
    "Imputed have 1 line worse vision",
    "Imputed have 2 lines worse vision"
  )
  
  kable(sensitivity_summary[, c("Delta", "Delta_Lines", "Interpretation",
                                "Mean_Imputed_Original", "Mean_Imputed_Shifted",
                                "Pct_VI_Imputed_Original", "Pct_VI_Imputed_Shifted")],
        caption = "MNAR Sensitivity Analysis: Effect of systematic differences in missing outcomes",
        col.names = c("Delta (logMAR)", "Lines on chart", "Interpretation",
                     "Mean VA (Original)", "Mean VA (Shifted)",
                     "% VI (Original)", "% VI (Shifted)"))
  
  # Create visualization
  par(mfrow = c(1, 2))
  
  # Plot 1: Mean VA by delta
  plot(sensitivity_summary$Delta, sensitivity_summary$Mean_Imputed_Shifted,
       type = "b", pch = 19,
       xlab = "Delta adjustment (logMAR)",
       ylab = "Mean imputed outcome VA (logMAR)",
       main = "Sensitivity to MNAR assumption",
       ylim = range(c(sensitivity_summary$Mean_Observed,
                     sensitivity_summary$Mean_Imputed_Shifted)))
  abline(h = sensitivity_summary$Mean_Observed[1], col = "blue", lty = 2)
  abline(v = 0, col = "gray", lty = 3)
  legend("topleft", c("Shifted imputed", "Observed mean"), 
         col = c("black", "blue"), lty = c(1, 2), pch = c(19, NA))
  
  # Plot 2: % VI by delta
  plot(sensitivity_summary$Delta, sensitivity_summary$Pct_VI_Imputed_Shifted,
       type = "b", pch = 19,
       xlab = "Delta adjustment (logMAR)",
       ylab = "% with vision impairment",
       main = "VI prevalence under MNAR",
       ylim = range(c(sensitivity_summary$Pct_VI_Observed,
                     sensitivity_summary$Pct_VI_Imputed_Shifted)))
  abline(h = sensitivity_summary$Pct_VI_Observed[1], col = "blue", lty = 2)
  abline(v = 0, col = "gray", lty = 3)
  legend("topleft", c("Shifted imputed", "Observed prevalence"), 
         col = c("black", "blue"), lty = c(1, 2), pch = c(19, NA))
  
  par(mfrow = c(1, 1))
  
  log_message("MNAR sensitivity analysis complete (diagnostic only - main imputation unchanged)")
}
```

## Create Complete Datasets and Derive Variables

```{r complete-datasets}
# Extract all imputed datasets
imputed_datasets <- complete(mice_results, action = "all")

# Apply transformation functions to recreate derived variables

imputed_datasets <- lapply(1:n_imputations, function(i) {
  imp_data <- imputed_datasets[[i]]
  
  # Apply transformation functions to recreate all derived variables
  imp_data <- imp_data |>
    create_outcome_variables() |>  # Creates outcome_va_vi_binary from logMAR
    create_age_cat() |>  # Creates age_cat from continuous age
    create_treatment_type() |>  # Creates treatment_type and any_treatment
    create_dr_severity_variables()  # Creates dr_severity factor from person_dr
  
  return(imp_data)
})

# Add back any variables not included in imputation or transformation
# Get the full original dataset with row IDs
df_original_full <- df_for_imputation |>
  mutate(row_id = row_number())

# Variables to add back (those not in imputation model or created by transformations)
vars_in_imputed <- names(imputed_datasets[[1]])
# Remove row_id from comparison since it's our join key
vars_to_add <- setdiff(names(df_original_full), c(vars_in_imputed, "row_id"))
```

### Adding Back Non-Imputed Variables

**Variables to add back:** `r if(length(vars_to_add) > 0) length(vars_to_add) else 0` variables not in imputation model

```{r add-back-vars}
if(length(vars_to_add) > 0) {
  # Add these variables back to each imputed dataset using row_id for exact matching
  imputed_datasets <- lapply(imputed_datasets, function(imp_data) {
    # Store original row count
    orig_rows <- nrow(imp_data)
    
    # Join using row_id for exact 1:1 matching
    imp_data <- imp_data |>
      left_join(
        df_original_full |> 
          dplyr::select(row_id, dplyr::all_of(vars_to_add)),
        by = "row_id"
      )
    
    # Verify no row duplication
    if (nrow(imp_data) != orig_rows) {
      stop("Join changed row count from ", orig_rows, " to ", nrow(imp_data), 
           ". This should not happen with row_id join.")
    }
    
    # Remove row_id as it's no longer needed
    imp_data <- imp_data |> select(-row_id)
    
    return(imp_data)
  })
}

completeness_check <- lapply(imputed_datasets, function(d) {
  sum(!complete.cases(d[, ps_model_vars]))
})

```

### Completeness Check

**Number of incomplete cases in PS model variables per imputed dataset:**
```{r completeness-results}
print(unlist(completeness_check))
```

## Save Imputed Datasets

```{r save-imputed}
saveRDS(mice_results, file.path(reanalysis_data_dir, "mice_results.rds"))
saveRDS(imputed_datasets, file.path(reanalysis_data_dir, "imputed_datasets.rds"))
saveRDS(imputed_datasets[[1]], file.path(reanalysis_data_dir, "imputed_dataset_1.rds"))
```

**Saved `r n_imputations` imputed datasets to:** `r reanalysis_data_dir`

```{r empty-chunk}
```

## Summary

```{r summary}
# Count variables more precisely
# Total columns in df_mice includes row_id which we added
total_vars <- ncol(df_mice)
id_vars <- 2  # row_id and e_mrn_deidentified
substantive_vars <- total_vars - id_vars  # Variables actually used in the imputation model

summary_table <- tibble(
  Metric = c(
    "Original observations",
    "Total variables in dataset",
    "ID variables (excluded from model)",
    "Substantive variables in imputation model",
    "Variables with missing data",
    "Variables actually imputed",
    "Number of imputations",
    "Maximum missing percentage",
    "Imputation iterations"
  ),
  Value = c(
    nrow(df_mice),
    total_vars,
    id_vars,
    substantive_vars,
    sum(mice_results$nmis > 0),
    length(vars_to_impute),
    n_imputations,
    paste0(round(max(mice_results$nmis/nrow(df_mice)) * 100, 1), "%"),
    mice_results$iteration
  )
)

summary_table |>
  kable(caption = "Multiple imputation summary")

imputed_vars <- names(mice_results$nmis)[mice_results$nmis > 0]
```

**Variables that were imputed:**
```{r imputed-vars-list}
print(imputed_vars)
```

### Temporal VA Imputation Summary

- **Baseline VA:** Starting point for temporal chain
- **Intermediate VA:** Bridge between baseline and 2-year outcome
  - For "submitted" cohort with observed outcome: set to outcome value
  - For "excluded" cohort: contains observed intermediate follow-up values
  - Reduces missing data substantially compared to leaving as NA
- **Outcome VA:** Final 2-year outcome (missing for 'excluded' cohort)
- **Temporal order enforced:** baseline → intermediate → outcome
- **No reverse-time prediction allowed**

```{r finalize-log}
# Finalize logging
log_message("Multiple imputation analysis completed successfully")
log_message(paste0("Total imputed datasets created: ", n_imputations))
final_log <- finalize_log(success = TRUE)
```

**Log file location:** `r final_log`

