---
title: "Reanalysis Step 2: Multiple Imputation"
subtitle: "Imputing missing values using mice package"
author: "Erik Westlund"
date: "`r Sys.Date()`"
format: html
---

## Setup

```{r setup}
#| include: false
source("dependencies.R")
seed <- 2025
setup_analysis(seed = seed)

# Additional packages for imputation
library(mice)
library(VIM)
library(naniar)

# ANALYSIS MODE: "test" or "final"
# test = 2 imputations, 5 iterations (fast)
# final = 30 imputations, 20 iterations (slow but thorough)
analysis_mode <- "final"  # Change to "final" for production run

# Set parameters based on mode
if (analysis_mode == "test") {
  n_imputations <- 2
  n_iterations <- 2
} else if (analysis_mode == "final") {
  n_imputations <- 10
  n_iterations <- 20
} else {
  stop("Invalid analysis_mode. Must be 'test' or 'final'")
}
```

**Running in `r toupper(analysis_mode)` mode:**  
- **Imputations:** `r n_imputations`  
- **Iterations:** `r n_iterations`

## Load Prepared Data

```{r load-data}
# Load the prepared dataset from Step 1
df_for_imputation <- readRDS(file.path(reanalysis_data_dir, "df_for_imputation.rds"))
variable_lists <- readRDS(file.path(reanalysis_data_dir, "variable_lists.rds"))

ps_model_vars <- variable_lists$ps_model_vars
outcome_model_vars <- variable_lists$outcome_model_vars
```

## Define Variables for Imputation

```{r define-imputation-vars}
# Variables to include in imputation model
# Include: outcome, exposure, all covariates source variables only
# Derived variables will be recreated post-imputation

# Core analysis variables - SOURCE ONLY
imputation_vars <- c(
  "e_mrn_deidentified",
  
  # Outcome variable - SOURCE ONLY
  "outcome_VA_logMAR",  # Continuous version (source)
  # NOT outcome_va_vi_binary - derived from logMAR >= 0.3
  
  # Exposure
  "ever_lapse_binary",
  
  # Demographics/Clinical
  "baseline_VA_logMAR",
  "gender_cat",
  "race_ethnic_cat",
  "insurance_cat",
  "age",  # Continuous age (source)
  # NOT age_cat - derived from cut(age)
  "CCI",
  "DCSI",
  
  # Treatment indicators - ALL SOURCES
  "other_inject",
  "anti_VEGF",
  "focal_laser_flag",
  "PRP_flag",
  # NOT treatment_type or any_treatment - derived from these 4
  
  # Comorbidities (already recoded to 0/1)
  "glaucoma_bef_hitplus_cat",
  "otherretina_bef_hitplus_cat",
  "catsurg_before_hitplus_cat",
  
  # DR severity - use person_dr (created from No_DR/NPDR/PDR)
  "person_dr"  # Numeric 0/1/2
  # NOT dr_severity or person_dr_severity - derived from person_dr
)

df_mice <- df_for_imputation |>
  mutate(
    # Create a unique row identifier to preserve exact row matching
    row_id = row_number()
  ) |>
  dplyr::select(row_id, dplyr::all_of(imputation_vars)) |>
  mutate(
    # Convert person_dr to ordered factor for polr imputation method
    person_dr = factor(person_dr, levels = c(0, 1, 2), 
                      labels = c("No_DR", "NPDR", "PDR"),
                      ordered = TRUE),
    # Lock factor levels for categorical variables to ensure consistency
    gender_cat = factor(gender_cat),
    race_ethnic_cat = factor(race_ethnic_cat),
    insurance_cat = factor(insurance_cat)
  )
```

## Setup Imputation Model

```{r setup-mice}
# Initialize mice
# First, do a dry run to check the imputation setup
mice_dry <- mice(df_mice, maxit = 0, printFlag = FALSE)

# Imputation model summary
miss_vars <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  Pct_Missing = round(mice_dry$nmis/nrow(df_mice) * 100, 1)
) |>
  filter(N_Missing > 0) |>
  arrange(desc(N_Missing))
```

### Initial Imputation Model Summary

**Total variables in dataset:** `r ncol(df_mice)`  
**Variables to be imputed:** `r sum(mice_dry$nmis > 0)`  
**Total missing values:** `r sum(mice_dry$nmis)`  

**Missing data by variable:**
```{r missing-vars-table}
kable(miss_vars)

method_table <- data.frame(
  Variable = names(mice_dry$method),
  Method = mice_dry$method,
  stringsAsFactors = FALSE
) |>
  filter(Method != "")
```

**Initial imputation methods by variable:**
```{r method-table}
kable(method_table)

# Customize imputation methods as needed
custom_methods <- mice_dry$method

custom_methods["CCI"] <- "pmm"  # Predictive mean matching for count data
custom_methods["DCSI"] <- "pmm"  # Predictive mean matching for count data
custom_methods["baseline_VA_logMAR"] <- "pmm"
custom_methods["age"] <- "pmm"
custom_methods["outcome_VA_logMAR"] <- "pmm"

# Use proportional odds model for ordinal person_dr (0/1/2)
custom_methods["person_dr"] <- "polr"  # Ordinal logistic regression

# Use logistic regression for binary variables
custom_methods["catsurg_before_hitplus_cat"] <- "logreg"

# Use polytomous regression for categorical variables with >2 levels
custom_methods["race_ethnic_cat"] <- "polyreg"
custom_methods["insurance_cat"] <- "polyreg"

# Don't impute these variables
# Method = "" means: don't impute (but still use as predictor EXCEPT for IDs)
custom_methods["row_id"] <- ""  # Row ID - never impute, never use as predictor; see below.
custom_methods["e_mrn_deidentified"] <- ""  # Patient ID - never impute, never use as predictor; see below.

# Variables that are complete (no missing data) - set method but won't actually be imputed
# Setting methods ensures correct measurement level is used IF they had missing data
custom_methods["ever_lapse_binary"] <- "logreg"  # Binary - complete
custom_methods["glaucoma_bef_hitplus_cat"] <- "logreg"  # Binary - already recoded to 0/1
custom_methods["otherretina_bef_hitplus_cat"] <- "logreg"  # Binary - already recoded to 0/1
custom_methods["gender_cat"] <- "logreg"  # Binary categorical - likely complete
custom_methods["other_inject"] <- "logreg"  # Binary - likely complete
custom_methods["anti_VEGF"] <- "logreg"  # Binary - likely complete  
custom_methods["focal_laser_flag"] <- "logreg"  # Binary - likely complete
custom_methods["PRP_flag"] <- "logreg"  # Binary - likely complete

# Note: Variables with complete data won't be imputed even if they have a method assigned
# The method specification ensures proper measurement level if imputation were needed

# Check predictor matrix (which variables predict which)
pred_matrix <- mice_dry$predictorMatrix

# Don't use IDs as predictors AND don't impute them
pred_matrix[, "e_mrn_deidentified"] <- 0
pred_matrix["e_mrn_deidentified", ] <- 0
pred_matrix[, "row_id"] <- 0
pred_matrix["row_id", ] <- 0

# Ensure outcome is used to predict missingness (important for MAR assumption)
pred_matrix[, "outcome_VA_logMAR"] <- 1
pred_matrix["outcome_VA_logMAR", "outcome_VA_logMAR"] <- 0  # Don't predict itself

# Ensure exposure is used as predictor
pred_matrix[, "ever_lapse_binary"] <- 1
pred_matrix["ever_lapse_binary", "ever_lapse_binary"] <- 0

```

### Final Imputation Model Configuration

```{r final-model-config}

# Get actual missing data information
missing_info <- data.frame(
  Variable = names(mice_dry$nmis),
  N_Missing = mice_dry$nmis,
  stringsAsFactors = FALSE
)

# Summary of methods
final_methods <- data.frame(
  Variable = names(custom_methods),
  Method = custom_methods,
  Type = dplyr::case_when(
    custom_methods == "" ~ "Excluded (IDs - not used as predictor)",
    custom_methods == "pmm" ~ "Predictive mean matching",
    custom_methods == "polr" ~ "Proportional odds regression",
    custom_methods == "logreg" ~ "Logistic regression",
    custom_methods == "polyreg" ~ "Polytomous regression",
    TRUE ~ custom_methods
  ),
  stringsAsFactors = FALSE
) |>
  left_join(missing_info, by = "Variable") |>
  mutate(
    Will_Be_Imputed = N_Missing > 0 & Method != "",
    Role = case_when(
      Variable %in% c("row_id", "e_mrn_deidentified") ~ "ID (excluded)",
      N_Missing == 0 & Method != "" ~ "Complete predictor",
      N_Missing > 0 & Method != "" ~ "To be imputed",
      TRUE ~ "Other"
    )
  )

# Sort to show meaningful groupings
final_methods <- final_methods |>
  dplyr::arrange(Role == "ID (excluded)", N_Missing == 0, Variable)

# Variables that will ACTUALLY be imputed (have missing data AND a method)
vars_to_impute <- final_methods |>
  filter(Will_Be_Imputed) |>
  pull(Variable)
```

**Imputation methods and missing data by variable:**
```{r final-methods-table}
final_methods |>
  select(Variable, Type, N_Missing, Role) |>
  kable(col.names = c("Variable", "Method Type", "Missing Values", "Role in Imputation"))
```

**Variables that will ACTUALLY be imputed** (have missing data, `r length(vars_to_impute)` total):
```{r vars-to-impute}
if (length(vars_to_impute) > 0) {
  data.frame(
    Variable = vars_to_impute,
    Missing_Count = final_methods |> 
      filter(Variable %in% vars_to_impute) |> 
      pull(N_Missing)
  ) |>
  kable()
} else {
  cat("No variables require imputation (all data complete)")
}

# Show complete variables with methods assigned
complete_with_methods <- final_methods |>
  filter(N_Missing == 0 & Method != "") |>
  select(Variable, Type)
```

**Complete variables with imputation methods assigned** (`r nrow(complete_with_methods)` total):
These variables have no missing data and won't be imputed, but have methods specified to ensure proper measurement level:
```{r complete-vars-table}
if (nrow(complete_with_methods) > 0) {
  kable(complete_with_methods, col.names = c("Variable", "Method Type"))
} else {
  cat("No complete variables with methods assigned")
}

# Show predictor matrix summary
# Get the number of predictors for each variable
predictors_per_var <- rowSums(pred_matrix)

# Separate by variable type
id_vars_pred <- predictors_per_var[c("row_id", "e_mrn_deidentified")]
imputed_vars_pred <- predictors_per_var[vars_to_impute]
other_vars_pred <- predictors_per_var[!names(predictors_per_var) %in% c("row_id", "e_mrn_deidentified", vars_to_impute)]

# Calculate meaningful statistics
n_predictors_for_imputed <- if(length(imputed_vars_pred) > 0) unique(imputed_vars_pred)[1] else NA
predictors <- names(which(colSums(pred_matrix) > 0))

# Verify IDs are excluded
ids_excluded <- all(pred_matrix[, "row_id"] == 0) & all(pred_matrix[, "e_mrn_deidentified"] == 0)
```

### Predictor Matrix Summary

**Number of predictors used:**
- For variables being imputed: **`r if(!is.na(n_predictors_for_imputed)) n_predictors_for_imputed else 0`** predictors each
- For ID variables: **0** predictors (excluded from imputation)

**ID variables properly excluded from predictors:** `r if(ids_excluded) "Yes" else "No"`

**Variables used as predictors** (`r length(predictors)` total):
```{r predictor-list}
if ("row_id" %in% predictors || "e_mrn_deidentified" %in% predictors) {
  warning("WARNING: ID variables are being used as predictors! This should not happen.")
}
print(predictors)
```

### Imputation Parameters

```{r imputation-params}
imp_params <- data.frame(
  Parameter = c("Mode", "Number of imputations (m)", "Max iterations (maxit)", "Random seed"),
  Value = c(analysis_mode, n_imputations, n_iterations, seed)
)
kable(imp_params)
```

## Run Multiple Imputation

```{r run-imputation}
# Run mice imputation
# Note: Parameters are set based on analysis_mode in setup
time_estimate <- if(analysis_mode == "test") "a few minutes" else "15-30 minutes or more"
```

**Starting multiple imputation...**

- Mode: `r analysis_mode`
- Imputations: `r n_imputations`
- Iterations: `r n_iterations`
- Estimated time: `r time_estimate`

```{r mice-run}

mice_results <- mice(
  df_mice,
  m = n_imputations,
  method = custom_methods,
  predictorMatrix = pred_matrix,
  maxit = n_iterations,  # Uses n_iterations from setup
  seed = 2025,
  printFlag = TRUE
)

# Check convergence
plot(mice_results)
```

## Imputation Diagnostics

**Note:** In the stripplots below, the leftmost column (labeled 1) shows the **original observed data** with missing values. Columns 2 through `r n_imputations + 1` show the imputed datasets.

```{r imputation-diagnostics}
# Check imputed values for key variables
# In mice stripplots: .imp = 1 is original data, .imp = 2+ are imputations

# CCI - compare observed vs imputed
if(sum(is.na(df_mice$CCI)) > 0) {
  cat("### Charlson Comorbidity Index (CCI)\n")
  cat("**Density plot:** Blue = observed data, Red = imputed values\n")
  densityplot(mice_results, ~ CCI) |> print()
  
  cat("\n**Stripplot:** Column 1 = original data (with gaps for missing), Columns 2+ = imputed datasets\n")
  stripplot(mice_results, CCI ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "CCI Distribution: Original vs Imputed") |> print()
  cat("\n")
}

# DCSI - compare observed vs imputed  
if(sum(is.na(df_mice$DCSI)) > 0) {
  cat("### Diabetes Complications Severity Index (DCSI)\n")
  cat("**Density plot:** Blue = observed data, Red = imputed values\n")
  densityplot(mice_results, ~ DCSI) |> print()
  
  cat("\n**Stripplot:** Column 1 = original data (with gaps for missing), Columns 2+ = imputed datasets\n")
  stripplot(mice_results, DCSI ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "DCSI Distribution: Original vs Imputed") |> print()
  cat("\n")
}

# Baseline VA - compare observed vs imputed
if(sum(is.na(df_mice$baseline_VA_logMAR)) > 0) {
  cat("### Baseline Visual Acuity (logMAR)\n")
  cat("**Density plot:** Blue = observed data, Red = imputed values\n")
  densityplot(mice_results, ~ baseline_VA_logMAR) |> print()
  
  cat("\n**Stripplot:** Column 1 = original data (with gaps for missing), Columns 2+ = imputed datasets\n")
  stripplot(mice_results, baseline_VA_logMAR ~ .imp, pch = 20, cex = 1.2,
            xlab = "Dataset (1=Original, 2+=Imputations)",
            main = "Baseline VA Distribution: Original vs Imputed") |> print()
  cat("\n")
}

# Person DR - compare observed vs imputed (categorical)
if(sum(is.na(df_mice$person_dr)) > 0) {
  # For categorical variables, check proportions across imputations
  # Extract each imputation and tabulate
  dr_props <- sapply(1:n_imputations, function(i) {
    imp_data <- complete(mice_results, i)
    prop.table(table(imp_data$person_dr))
  })
  
  # Create summary table
  dr_summary <- data.frame(
    Category = c("No_DR", "NPDR", "PDR"),
    Mean_Proportion = c(round(mean(dr_props[1,]), 3), 
                       round(mean(dr_props[2,]), 3),
                       round(mean(dr_props[3,]), 3)),
    SD = c(round(sd(dr_props[1,]), 3),
           round(sd(dr_props[2,]), 3), 
           round(sd(dr_props[3,]), 3))
  )
  kable(dr_summary, caption = "DR severity proportions across imputations")
  
  # Visual check if stripplot works with factors
  tryCatch({
    stripplot(mice_results, person_dr ~ .imp, pch = 20, cex = 1.2) |> print()
  }, error = function(e) {
    # Note: Stripplot not available for categorical person_dr
  })
}

# Check imputation quality for categorical variables
# Cataract surgery
if(sum(is.na(df_mice$catsurg_before_hitplus_cat)) > 0) {
  # Extract proportions for each imputation
  cat_props <- sapply(1:n_imputations, function(i) {
    imp_data <- complete(mice_results, i)
    prop.table(table(imp_data$catsurg_before_hitplus_cat))
  })
  
  # Create summary table for cataract surgery proportions
  if(is.matrix(cat_props)) {
    cat_summary <- data.frame(
      Level = rownames(cat_props),
      Mean_Proportion = apply(cat_props, 1, mean) |> round(3),
      SD = apply(cat_props, 1, sd) |> round(3)
    )
  } else {
    cat_summary <- data.frame(
      Level = "Cataract Surgery",
      Mean_Proportion = round(mean(cat_props), 3),
      SD = round(sd(cat_props), 3)
    )
  }
  kable(cat_summary, caption = "Cataract surgery proportions across imputations")
}
```

## Create Complete Datasets and Derive Variables

```{r complete-datasets}
# Extract all imputed datasets
imputed_datasets <- complete(mice_results, action = "all")

# Apply transformation functions to recreate derived variables

imputed_datasets <- lapply(1:n_imputations, function(i) {
  imp_data <- imputed_datasets[[i]]
  
  # Apply transformation functions to recreate all derived variables
  imp_data <- imp_data |>
    create_outcome_variables() |>  # Creates outcome_va_vi_binary from logMAR
    create_age_cat() |>  # Creates age_cat from continuous age  
    create_treatment_type() |>  # Creates treatment_type and any_treatment
    create_dr_severity_variables()  # Creates dr_severity factor from person_dr
  
  return(imp_data)
})

# Add back any variables not included in imputation or transformation
# Get the full original dataset with row IDs
df_original_full <- df_for_imputation |>
  mutate(row_id = row_number())

# Variables to add back (those not in imputation model or created by transformations)
vars_in_imputed <- names(imputed_datasets[[1]])
# Remove row_id from comparison since it's our join key
vars_to_add <- setdiff(names(df_original_full), c(vars_in_imputed, "row_id"))
```

### Adding Back Non-Imputed Variables

**Variables to add back:** `r if(length(vars_to_add) > 0) length(vars_to_add) else 0` variables not in imputation model

```{r add-back-vars}
if(length(vars_to_add) > 0) {
  # Add these variables back to each imputed dataset using row_id for exact matching
  imputed_datasets <- lapply(imputed_datasets, function(imp_data) {
    # Store original row count
    orig_rows <- nrow(imp_data)
    
    # Join using row_id for exact 1:1 matching
    imp_data <- imp_data |>
      left_join(
        df_original_full |> 
          dplyr::select(row_id, dplyr::all_of(vars_to_add)),
        by = "row_id"
      )
    
    # Verify no row duplication
    if (nrow(imp_data) != orig_rows) {
      stop("Join changed row count from ", orig_rows, " to ", nrow(imp_data), 
           ". This should not happen with row_id join.")
    }
    
    # Remove row_id as it's no longer needed
    imp_data <- imp_data |> select(-row_id)
    
    return(imp_data)
  })
}

completeness_check <- lapply(imputed_datasets, function(d) {
  sum(!complete.cases(d[, ps_model_vars]))
})

```

### Completeness Check

**Number of incomplete cases in PS model variables per imputed dataset:**
```{r completeness-results}
print(unlist(completeness_check))
```

## Save Imputed Datasets

```{r save-imputed}
saveRDS(mice_results, file.path(reanalysis_data_dir, "mice_results.rds"))
saveRDS(imputed_datasets, file.path(reanalysis_data_dir, "imputed_datasets.rds"))
saveRDS(imputed_datasets[[1]], file.path(reanalysis_data_dir, "imputed_dataset_1.rds"))
```

**Saved `r n_imputations` imputed datasets to:** `r reanalysis_data_dir`

```{r empty-chunk}
```

## Summary

```{r summary}
# Count variables more precisely
# Total columns in df_mice includes row_id which we added
total_vars <- ncol(df_mice)
id_vars <- 2  # row_id and e_mrn_deidentified
substantive_vars <- total_vars - id_vars  # Variables actually used in the imputation model

summary_table <- tibble(
  Metric = c(
    "Original observations",
    "Total variables in dataset",
    "ID variables (excluded from model)",
    "Substantive variables in imputation model",
    "Variables with missing data",
    "Variables actually imputed",
    "Number of imputations",
    "Maximum missing percentage",
    "Imputation iterations"
  ),
  Value = c(
    nrow(df_mice),
    total_vars,
    id_vars,
    substantive_vars,
    sum(mice_results$nmis > 0),
    length(vars_to_impute),
    n_imputations,
    paste0(round(max(mice_results$nmis/nrow(df_mice)) * 100, 1), "%"),
    mice_results$iteration
  )
)

summary_table |>
  kable(caption = "Multiple imputation summary")

imputed_vars <- names(mice_results$nmis)[mice_results$nmis > 0]
```

**Variables that were imputed:**
```{r imputed-vars-list}
print(imputed_vars)
```

